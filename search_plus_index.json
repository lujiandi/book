{"./":{"url":"./","title":"简介","keywords":"","body":"Markdown Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 标题 # h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 换行 四个及以上空格加回车。 链接 跳至[落网](http://www.luoo.net/) 新窗口跳至落网 带 title 的链接 [落网](http://www.luoo.net/ '落网') 地址与文字一样的链接的简写 图片 ![头像](https://avatars0.githubusercontent.com/u/2120155?v=3&s=40) 有序列表 1. 第一个 1. 第 1.1 个 1. 第二个 1. 第三个 无序列表 * 葡萄 * 夏黑 * 巨峰 * 荔枝 * 梨 强调 **强调内容** 斜体 *斜体内容* 分割线 **** 表格 | Tables | Are | Cool | | :------------ | :-----------: | -----: | | col 3 is | right-aligned | \\$1600 | | col 2 is | centered | \\$12 | | zebra stripes | are neat | \\$1 | 引用 > 天才就是 99%的努力加上 1%的灵感。-爱迪生 复选框 - [x] Be awesome - [ ] Prepare dinner - [x] Research recipe - [ ] Buy ingredients - [ ] Cook recipe - [ ] Sleep 转义 \\*sth\\* "},"gitbooktutorial/":{"url":"gitbooktutorial/","title":"GitBook 教程","keywords":"","body":"GitBook 是什么 GitBook 是使用 GitHub \\/ Git 和 Markdown（或 AsciiDoc）构建漂亮书籍的命令行工具（和 Node.js 库）。 GitBook 可以将您的内容作为网站（可定制和可扩展）或电子书（PDF，ePub 或 Mobi）输出。 GitBook.com 是使用 GitBook 格式创建和托管图书的在线平台。它提供托管，协作功能和易于使用的编辑器。 "},"gitbooktutorial/installation.html":{"url":"gitbooktutorial/installation.html","title":"安装","keywords":"","body":"GitBook 安装 目录 本地安装 环境要求 安装 GitBook 是很简单的。您的系统只需要满足这两个要求： NodeJS（推荐使用v4.0.0及以上版本） Windows，Linux，Unix 或 Mac OS X 通过NPM安装 安装 GitBook 的最好办法是通过 NPM。在终端提示符下，只需运行以下命令即可安装 GitBook： $ npm install gitbook-cli -g gitbook-cli 是 GitBook 的一个命令行工具。它将自动安装所需版本的 GitBook 来构建一本书。 执行下面的命令，查看 GitBook 版本，以验证安装成功。 $ gitbook -V 安装历史版本 gitbook-cli 可以轻松下载并安装其他版本的GitBook来测试您的书籍： $ gitbook fetch beta 使用 gitbook ls-remote 会列举可以下载的版本。 创建一本书 初始化 GitBook可以设置一个样板书： $ gitbook init 如果您希望将书籍创建到一个新目录中，可以通过运行 gitbook init ./directory 这样做。 构建 使用下面的命令，会在项目的目录下生成一个 _book 目录，里面的内容为静态站点的资源文件： $ gitbook build Debugging 您可以使用选项 --log=debug 和 --debug 来获取更好的错误消息（使用堆栈跟踪）。例如： $ gitbook build ./ --log=debug --debug 启动服务 使用下列命令会运行一个 web 服务, 通过 http://localhost:4000/ 可以预览书籍 $ gitbook serve "},"gitbooktutorial/commands.html":{"url":"gitbooktutorial/commands.html","title":"命令","keywords":"","body":"GitBook 命令 这里主要介绍一下 GitBook 的命令行工具 gitbook-cli 的一些命令, 首先说明两点: gitbook-cli 和 gitbook 是两个软件 gitbook-cli 会将下载的 gitbook 的不同版本放到 ~/.gitbook中, 可以通过设置GITBOOK_DIR环境变量来指定另外的文件夹 列出 gitbook 所有的命令 gitbook help 输出 gitbook-cli 的帮助信息 gitbook --help 生成静态网页 gitbook build 生成静态网页并运行服务器 gitbook serve 生成时指定gitbook的版本, 本地没有会先下载 gitbook build --gitbook=2.0.1 列出本地所有的gitbook版本 gitbook ls 列出远程可用的gitbook版本 gitbook ls-remote 安装对应的gitbook版本 gitbook fetch 标签/版本号 更新到gitbook的最新版本 gitbook update 卸载对应的gitbook版本 gitbook uninstall 2.0.1 指定log的级别 gitbook build --log=debug 输出错误信息 gitbook builid --debug "},"gitbooktutorial/structure.html":{"url":"gitbooktutorial/structure.html","title":"结构","keywords":"","body":"Gitbook 目录结构 目录 GitBook 项目结构 GitBook 使用简单的目录结构。在 SUMMARY （即 SUMMARY.md 文件）中列出的所有 Markdown / Asciidoc 文件将被转换为 HTML。多语言书籍结构略有不同。 一个基本的 GitBook 电子书结构通常如下： . ├── book.json ├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md GitBook 特殊文件的功能： 文件 描述 book.json 配置数据 (optional) README.md 电子书的前言或简介 (required) SUMMARY.md 电子书目录 (optional) GLOSSARY.md 词汇/注释术语列表 (optional) 静态文件和图片 静态文件是在 SUMMARY.md 中未列出的文件。除非被忽略，否则所有静态文件都将复制到输出路径。 忽略文件和文件夹 GitBook 将读取 .gitignore，.bookignore 和 .ignore 文件，以获取要过滤的文件和文件夹。这些文件中的格式遵循 .gitignore 的规则： # This is a comment # Ignore the file test.md test.md # Ignore everything in the directory \"bin\" bin/* 项目与子目录集成 对于软件项目，您可以使用子目录（如 docs/ ）来存储项目文档的图书。您可以配置根选项来指示 GitBook 可以找到该图书文件的文件夹： . ├── book.json └── docs/ ├── README.md └── SUMMARY.md 在 book.json 中配置以下内容： { \"root\": \"./docs\" } Summary GitBook 使用 SUMMARY.md 文件来定义本书的章节和子章节的结构。 SUMMARY.md 文件用于生成本书的目录。 SUMMARY.md 的格式是一个链接列表。链接的标题将作为章节的标题，链接的目标是该章节文件的路径。 向父章节添加嵌套列表将创建子章节。 简单示例： # Summary * [Part I](part1/README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) * [Part II](part2/README.md) * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) 每章都有一个专用页面（part#/README.md），并分为子章节。 锚点 目录中的章节可以使用锚点指向文件的特定部分。 # Summary ### Part I * [Part I](part1/README.md) * [Writing is nice](part1/README.md#writing) * [GitBook is nice](part1/README.md#gitbook) * [Part II](part2/README.md) * [We love feedback](part2/README.md#feedback) * [Better tools for authors](part2/README.md#tools) 部分 目录可以分为以标题或水平线 ---- 分隔的部分： # Summary ### Part I * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) ---- * [Last part without title](part3/title.md) Parts 只是章节组，没有专用页面，但根据主题，它将在导航中显示。 页面 Markdown 语法 默认情况下，GitBook 的大多数文件都使用 Markdown 语法。 GitBook 推荐使用这种语法。所使用的语法类似于 GitHub Flavored Markdown syntax 。 此外，你还可以选择 AsciiDoc 语法。 页面内容示例： # Title of the chapter This is a great introduction. ## Section 1 Markdown will dictates _most_ of your **book's structure** ## Section 2 ... 页面前言 页面可以包含一个可选的前言。它可以用于定义页面的描述。前面的事情必须是文件中的第一件事，必须采取在三虚线之间设置的有效 YAML 的形式。这是一个基本的例子： --- description: This is a short description of my page --- # The content of my page ... Glossary 允许您指定要显示为注释的术语及其各自的定义。根据这些术语，GitBook 将自动构建索引并突出显示这些术语。 GLOSSARY.md 的格式是 h2 标题的列表，以及描述段落： ## Term Definition for this term ## Another term With it's definition, this can contain bold text and all other kinds of inline markup ... "},"gitbooktutorial/settings.html":{"url":"gitbooktutorial/settings.html","title":"配置","keywords":"","body":"Gitbook 配置 GitBook 允许您使用灵活的配置自定义您的电子书。 这些选项在 book.json 文件中指定。对于不熟悉 JSON 语法的作者，您可以使用 JSONlint 等工具验证语法。 目录 常规设置 变量 描述 root 包含所有图书文件的根文件夹的路径，除了 book.json structure 指定自述文件，摘要，词汇表等的路径，参考 Structure paragraph. title 您的书名，默认值是从 README 中提取出来的。在 GitBook.com 上，这个字段是预填的。 description 您的书籍的描述，默认值是从 README 中提取出来的。在 GitBook.com 上，这个字段是预填的。 author 作者名。在GitBook.com上，这个字段是预填的。 isbn 国际标准书号 ISBN language 本书的语言类型 —— ISO code 。默认值是 en direction 文本阅读顺序。可以是 rtl （从右向左）或 ltr （从左向右），默认值依赖于 language 的值。 gitbook 应该使用的GitBook版本。使用 SemVer 规范，并接受类似于 “> = 3.0.0” 的条件。 author 作者姓名，在GitBook.com上，这个字段是预先填写的。 例： \"author\" : \"Zhang Peng\" description 电子书的描述，默认值是从 README 中提取出来的。在GitBook.com上，这个字段是预先填写的。 例： \"description\" : \"Gitbook 教程\" direction 文本的方向。可以是 rtl 或 ltr，默认值取决于语言的值。 例： \"direction\" : \"ltr\" gitbook 应该使用的GitBook版本。使用SemVer规范，接受类似于 >=3.0.0 的条件。 例： \"gitbook\" : \"3.0.0\", \"gitbook\" : \">=3.0.0\" language Gitbook使用的语言, 版本2.6.4中可选的语言如下： en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 例： \"language\" : \"zh-hans\", links 在左侧导航栏添加链接信息 例： \"links\" : { \"sidebar\" : { \"Home\" : \"https://github.com/dunwu/gitbook-notes\" } } root 包含所有图书文件的根文件夹的路径， book.json 文件除外。 例： \"root\" : \"./docs\", structure 指定 Readme、Summary、Glossary 和 Languages 对应的文件名。 styles 自定义页面样式， 默认情况下各generator对应的css文件 例： \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 例如要使 h1、h2 标签有下边框， 可以在 website.css 中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } title 电子书的书名，默认值是从 README 中提取出来的。在 GitBook.com 上，这个字段是预先填写的。 例： \"title\" : \"gitbook-notes\", plugins 插件及其配置在 book.json 中指定。有关详细信息。 自 3.0.0 版本开始，GitBook 可以使用主题。有关详细信息，请参阅 the theming section 。 变量 描述 plugins 要加载的插件列表 pluginsConfig 插件的配置 添加插件 \"plugins\": [ \"splitter\" ] 添加新插件之后需要运行 gitbook install 来安装新的插件 去除自带插件 Gitbook 默认带有 5 个插件： highlight search sharing font-settings livereload \"plugins\": [ \"-search\" ] structure 除了 root 属性之外，您可以指定 Readme，Summary，Glossary 和 Languages 的名称（而不是使用默认名称，如README.md）。这些文件必须在项目的根目录下（或 root 的根目录，如果你在 book.json 中配置了 root 属性）。不接受的路径，如：dir / MY_README.md。 变量 描述 structure.readme Readme 文件名（默认值是 README.md ） structure.summary Summary 文件名（默认值是 SUMMARY.md ） structure.glossary Glossary 文件名（默认值是 GLOSSARY.md ） structure.languages Languages 文件名（默认值是 LANGS.md ） pdf 可以使用 book.json 中的一组选项来定制PDF输出： Variable Description pdf.pageNumbers 将页码添加到每个页面的底部（默认为 true） pdf.fontSize 基本字体大小（默认是 12） pdf.fontFamily 基本字体样式（默认是 Arial） pdf.paperSize 页面尺寸，选项有： 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'legal', 'letter' （默认值是 a4） pdf.margin.top 上边界（默认值是 56） pdf.margin.bottom 下边界（默认值是 56） pdf.margin.right 右边界（默认值是 62） pdf.margin.left 左边界（默认值是 62） "},"gitbooktutorial/deploy.html":{"url":"gitbooktutorial/deploy.html","title":"发布","keywords":"","body":"Gitbook 部署 托管到 gitbook.com GitBook.com 是使用 GitBook 格式创建和托管图书的在线平台。它提供托管，协作功能和易于使用的编辑器。 创建新书 如下图所示，根据个人需求，选择一个模板创建你的电子书。 设置书的基本信息 clone 到本地 Gitbook.com 会为每本书创建一个 git 仓库。 如下图所示，拷贝 git 地址，然后 git clone 到本地。 发布 在本地按照 Gitbook 规范编辑电子书，然后 git push 到 Gitbook 的远程仓库。 默认访问地址是：https://用户名.gitbooks.io/项目名/content/ 例如：我的用户名为 dunwu，一个电子书项目名为 test，则访问路径是： https://dunwu.gitbooks.io/test/content/ 当然，如果你有自己的域名，也可以设置 Domains 选项，来指定访问路径为你的域。 托管到 Github 如果你不希望使用 Gitbook 的仓库，而是想直接使用 Github 的仓库，也是可以的。 首先，你需要绑定你的 Github 账号。最简单的方式当然就是登录 Gitbook.com 时使用 Github 账号登录方式了。否则，你也可以在 Account Settings 中的 Github 设置选项中去进行绑定。 绑定了 Github 账号后，你可以在新建电子书时，选择从一个指定的 Github 仓库导入电子书项目。参考下图： 只要你指定的 Github 仓库中的文档内容符合 Gitbook 规范，Gitbook 就会自动根据你的每次更新去构建生成电子书网站。 默认访问地址是： https://Github用户名.gitbooks.io/Github 仓库/content/ 例如：我的用户名为 dunwu，Github 仓库名为 gitbook-notes，则访问路径是： https://dunwu.gitbooks.io/gitbook-notes/content/ 托管到 Github Pages 也许你以前也了解 Github 的一个功能： GitHub Pages 。它允许用户在 GitHub 仓库托管你的个人、组织或项目的静态页面（自动识别 html、css、javascript）。Gitee 也有同样功能 Gitee Pages,下面操作基本一样；访问 用户名.gitee.io/项目名。 建立 用户名.github.io 仓库 要使用这个特性，首先，你必须建立一个严格遵循以下命名要求的仓库：Github账号名.github.io 建立 gh-pages 分支 完成第 1 步后，在任意一个 Github 仓库中建立一个名为 gh-pages 的分支。只要 gh-pages 中的内容符合一个静态站点要求，就可以在如下地址中进行访问：https://Github用户名.gitbooks.io/仓库名 。 自动化发布到 gh-pages 如果每次都手动 git push 到远程 gh-pages 分支，略有点麻烦。 怎么实现自动化发布呢？ 有两种方法： 使用 gh-pages 插件 先在本地安装插件 $ npm i -D gh-pages 然后，在 package.json 文件中添加脚本命令： 如下：-d 命令参数后面是要发布的静态站点内容的目录 \"scripts\": { \"自定义命令\": \"gh-pages -d 打包输出目录\" }, 脚本 写一个执行 git 命令的脚本就搞定了。 下面的脚本无论是在 bat 或 sh 脚本中都可以执行。 cd 打包输出目录 git init git checkout -b gh-pages git add . git commit -am \"Update\" git push git@github.com:用户名/仓库名 gh-pages --force\" "},"gitbooktutorial/generating-ebooks-and-pdfs.html":{"url":"gitbooktutorial/generating-ebooks-and-pdfs.html","title":"生成电子书","keywords":"","body":"生成电子书 目录 GitBook 可以生成一个网站，但也可以输出内容作为电子书（ePub，Mobi，PDF）。 # Generate a PDF file $ gitbook pdf ./ ./mybook.pdf # Generate an ePub file $ gitbook epub ./ ./mybook.epub # Generate a Mobi file $ gitbook mobi ./ ./mybook.mobi 安装 ebook-convert `ebook-convert` 可以用来生成电子书（epub，mobi，pdf）。 win需要安装calibre GNU/Linux 安装 Calibre application. $ sudo aptitude install calibre 在一些 GNU / Linux 发行版中，节点被安装为 nodejs，您需要手动创建一个符号链接： $sudo ln -s /usr/bin/nodejs /usr/bin/node OS X 下载 Calibre application。将 calibre.app 移动到应用程序文件夹后，创建一个符号链接到 ebook-convert 工具： $ sudo ln -s ~/Applications/calibre.app/Contents/MacOS/ebook-convert /usr/bin 您可以使用 $PATH 中的任何目录替换 /usr/bin 。 封面 封面用于所有电子书格式。您可以自己提供一个，也可以使用 gitbook-plugin-autocover 生成一个。 要提供封面，请将 cover.jpg 文件放在书本的根目录下。添加一个 cover_small.jpg 将指定一个较小版本的封面。封面应为 JPEG 文件。 好的封面应该遵守以下准则： cover.jpg 的尺寸为 1800x2360 像素，cover_small.jpg 为 200x262 没有边界 清晰可见的书名 任何重要的文字应该在小版本中可见 "},"gitbooktutorial/resources.html":{"url":"gitbooktutorial/resources.html","title":"资源","keywords":"","body":"资源 官方资源 Gitbook Github Gitbook 官网 Gitbook Toolchain 文档 Gitbook 帮助中心 教程资源 gitbook-use by zhangjikai 工具 Gitbook 编辑器 "},"soft/":{"url":"soft/","title":"软件安装配置","keywords":"","body":"软件安装配置 "},"soft/jdk/jdk.html":{"url":"soft/jdk/jdk.html","title":"Jdk","keywords":"","body":"JDK 安装 设置系统环境变量: JAVA_HOME: D:\\developer\\Java\\jdk1.8.0_152 classpath: .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 添加到 Path 变量:D:\\developer\\Java\\jdk1.8.0_152\\bin "},"soft/git/git.html":{"url":"soft/git/git.html","title":"Git","keywords":"","body":"﻿ Git github 账号 微软 outlook 邮箱 git 配置   在使用 git 之前你需要配置一下 git。git 在你创建提交的时候会记录你的名字和 email 地址，所以你应该告诉 git 这些内容。可以使用'git config'命令来设置。 git config --list git config --global user.name \"你的用户名\" git config --global user.email \"你的邮箱\" git config --global core.autocrlf false 创建 SSH Key 创建 SSH Key： ssh-keygen -t rsa -C 你的邮箱 将生成的 id_rsa.pub 里面的内容复制到 github 的 add ssh 中 验证 github: ssh -T git@github.com 验证 gitee: ssh -T git@gitee.com gist.github.com 被墙无法访问解决办法   windows 下 打开 C:\\Windows\\System32\\drivers\\etc\\hosts 文件 编辑器打开，在最后行添加 192.30.253.118 gist.github.com 创建本地仓库并推送到远程的过程 在远程创建 repository,获得远程仓库地址(https/ssh)如：https://github.com/lujiandi/mmall.git 新建一个目录 [project-name] 创建配置 .gitignore 文件，忽略指定类型的文件和目录。 创建文件 README.md 项目初始化(git init) 添加文件(单个文件指定文件名) git add . 提交本地 git commit -am \"commit message\" 连接到远程 git remote add origin https://github.com/lujiandi/mmall.git 推送到远程 xxx 分支(强制推 加上 -f ) git push -u origin xxx 其它命令 状态(查看有哪些文件发生变化) git status 查看 tag git tag 添加 tag git tag -a vx.x.x -m \"vx.x.x 版本\" 推送 tag git push -u origin xxxx 删除 tag git tag -d xxx 删除远程 tag git push origin :refs/tags/xxxx 查看分支 git branch git branch -a #查看远程分支 git branch -r 根据原有分支创建进切换到新分支 git checkout -b v1.0 origin/master 切换分支 git checkout xxx 删除分支 git branch -d xxxx 删除远程分支 git push origin --delete xxxx (拉)更新远程到本地， git pull log 本地提交记录 可以回到过去 git log reflog 当前版本的记录 git reflog 取消暂存 git reset HEAD fileName 恢复文件 git checkout fileName 本地回到某次提交的版本(影响所有文件) git reset --hard 04f76726c53d58992dfb2d55417b0eb9452c75b2 diff(没有 commit) git diff #比较工作区与暂存区文件的差异 merge 合并 xxx 到前分支 git merge xxx 下载一个项目和它的整个代码历史 git clone [url] 远程关联 git remote -v ：查看远程关联 git remote add xxx 远程地址 ：关联远程,xxx 为远程仓库名，git push -u xxxx 本地分支 git remote remove xxx :取消关联 gitflow "},"soft/idea/idea.html":{"url":"soft/idea/idea.html","title":"Idea","keywords":"","body":"Idea win 下修改 idea 缓存和配置的默认路径 在安装目录创建.IntelliJIdea 目录 进入安装目录的 bin 文件夹修改 idea.propertiesidea.config.path=D:/IDE/IntelliJ IDEA 2017.1.3/.IntelliJIdea/config idea.system.path=D:/IDE/IntelliJ IDEA 2017.1.3/.IntelliJIdea/system 启动选项 -Dfile.encoding=UTF-8 tomcat 启动打印不会乱码 IntelliJ IDEA SpringBoot 热部署 设置 Complier>build project automatically 设置 Registry>compiler.automake.allow.when.app.running 窗口切换 Alt+数字：可跳转并打开指定的窗口，例: Alt+1 打开 Project 窗口 alt+f12 terminal shift+esc 隐藏工具窗口 alt+Right/Left 切换编辑窗口 Esc 进入编辑窗口 ctrl+alt+[/] 项目窗口切换 ctrl+alt+Right/Left 浏览位置切换 ctrl+shift+backspace 上一处编辑的地方 ctrl+f4 关闭编辑窗口 ctrl+G 快速定位到行 emacsIDEAs 插件快速定位 先按下 ctrl+j,再按下字母，三 按下对应标记完成跳转 搜索 ctrl+shift+f 字符 ctrl+n 搜索类 Ctrl+E 最近浏览文件 Ctrl+Shift+E 最近修改文件 ctrl+shift+n 搜索文件 ctrl+shift+alt+n 搜索函数或者符号 double shift search everywhere Ctrl+Shift+A：可搜索 idea 任意的功能选项 查看类/函数信息 ctrl+b 查看类或者函数使用的地方(定义) ctrl+alt+b 查看类或者函数的实现 ctrl+p 查看方法参数信息 ctrl+f12 查看类的结构 ctrl+q 查看注释 ctrl+u 查看父类 ctrl+h 查看继承链 ctrl+alt+h (查看函数调用结构) ctrl+shift+alt+u （查看 maven 依赖结构图、java 关系图） 书签 ctrl+f11 标记/取消书签 ctrl+标记 切换书签 shift+f11 显示所有书签 编辑 ctrl+w 选中一个单词 ctrl+shift+u 大小写 ctrl+d 复制当前行 ctrl+y 删除当前行 ctrl+shift+r 替换 ctrl+shift+up/down 上下移动 ctrl+o 复写方法 ctrl+alt+L 格式化代码 shift+alt+click 多光标操作 Alt + J 选中下一个匹配项 Ctrl + Alt + Shift + J 选中所有匹配项 shift+alt+insert 进入或者取消多光标模式 shift+ctrl+t 生成测试方法 alt+insert 代码生成 alt+enter Show intention actions and 代码修复 Ctrl + Shift + Space 代码提示 Ctrl + Shift + Enter 修复语法错误 重构 f5 复制文件 F6 移动文件 shift+f6 重命名 抽取变量：ctrl + alt + v（refactor 选项） 抽取静态变量：ctrl + alt + c（refactor 选项） 抽取成员变量：ctrl + alt + f（refactor 选项） 将变量抽取成方法作为参数：Ctrl+Alt+P 抽取函数：ctrl + alt + m ctrl+alt+t surround with debug ctrl+f8 添加断点 ctrl+shift+f8 查看所有断点/条件断点 shift+alt+f9 debug f9 运行到下一个断点没有则结束 f8 step over f7 step into alt+f8 evaluate Expression 查看表达式 git(vcs) rclick 所在行 勾选 annotate(版本信息) ctrl+shift+alt+(up/down) (寻找改动的地方,没有 commit 才有效) ctrl+alt+z (撤销) local history (本地历史记录,不用 git 也可以) Put Label：（相当于给自己的本地修改做一份存档,不用 git 也可以） "},"soft/vscode/vscode.html":{"url":"soft/vscode/vscode.html","title":"vscode","keywords":"","body":"vscode vscode 引入 jq 代码提示 在项目目录创建 jsconfig.json,添加: { \"exclude\": [\"node_modules\"], \"typeAcquisition\": { \"include\": [ \"jquery\" ] } } 插件和设置同步 安装 Setting Sync 插件,同步到 GitHub Gist "},"soft/tomcat/tomcat.html":{"url":"soft/tomcat/tomcat.html","title":"tomcat","keywords":"","body":"Tomcat tomcat 目录结构: WEB 应用的 WEB-INF 目录结构 Tomcat 安装 解压安装包 添加环境变量，CATALINA_HOME ,变量值为包的根目录 启动服务器 bin 下 startup.dat 或者命令行运行 catalina.bat run 测试首页 浏览器：http://localhost:8080/ shutdomn.dat 关闭 tomcat 服务器 /webapps 服务器发布的 web 的 app 修改 tomcat(conf/server.xml) URIEncoding 单机部署多个 tomcat win # 修改环境变量 CATALINA_HOME:tomcat1安裝目录 CATALINA_BASE:tomcat1安裝目录 TOMCAT_HOME:tomcat1安裝目录 CATALINA_2_BASE:tomcat2安装目录 CATALINA_2_HOME:tomcat2安装目录 TOMCAT_2_HOME:tomcat2安装目录 # 修改第二个tomcat server.xml # 修改第二个tomcat catalina.bat startup.bat CATALINA_BASE 替换 CATALINA_2_BASE CATALINA_HOME 替换 CATALINA_2_HOME linux # 修改环境变量(vim /etc/pofile) CATALINA_HOME:tomcat1安裝目录 CATALINA_BASE:tomcat1安裝目录 TOMCAT_HOME:tomcat1安裝目录 CATALINA_2_BASE:tomcat2安装目录 CATALINA_2_HOME:tomcat2安装目录 TOMCAT_2_HOME:tomcat2安装目录 # 修改第二个tomcat server.xml # 修改第二个tomcat的catalina.sh,添加: export CATALINA_BASE=$CATALINA_2_BASE export CATALINA_HOME=$CATALINA_2_HOME "},"soft/redis/redis.html":{"url":"soft/redis/redis.html","title":"redis","keywords":"","body":"什么是 NoSQL NoSQL = Not Only SQL 非关系型数据库 为什么使用 NoSQL 高并发读写 海量数据存储和访问 高可拓展和可用性 Nosql 数据库比较 redis 数据类型 Redis 应用场景 缓存 任务队列 应用排行榜 网站访问统计 数据过期处理 分布式集群架构中的 Session 分离 web https://redis.io/ https://github.com/MSOpenTech/redis/releases win 安装 win 添加 redis 到系统服务(以配置文件启动,多个 redis 修改端口号),在 redis 安装目录下创建.bat 文件，添加: @echo off cd /d %~dp0 redis-server.exe --service-install redis.windows.conf --loglevel verbose --service-name Redis6379 pause redis 启动后生产 RedisQFork_xxx.dat 文件占用用户目录;修改 redis.windows.conf 中的 heapdir,改为安装目录 常用命令 # connect redis-cli -p 6379 # 监听 monitor # 删除 flushdb # 过期时间 -1:表示永久 ttl # 数据类型 type key # 获得keys keys * # 是否存在 exists key # 重置有效期 expire key String 类型 1. set key value 设置key的value值 2. get key 获取key的value值 3. getset key value 先获取key的value值，再重新赋值 4. del key 删除key键 5. incr key 为key的value值+1，若key不存在，则把value赋值为0后+1；若value数据类型不为integer，则报错。 6. decr key 为key的value值-1，若key不存在，则把value赋值为0后-1；若value数据类型不为integer，则报错。 7. append key 追加字符串 hash 类型 1. 存储k/v hset key k v 2. 取k对应的v hget key k 3. 删除键k hdel key k 4. 对k加上一个增量(可以为负) hincrby key k delta 5. 对k加上一个浮点数(可以为负) hincrbyfloat key k delta 6. 存储多个k/v对 hmset key k1 v1 k2 v2 ... kn vn 7. 取多个k对应的值 hmset key k1 k2 ... kn 8. 取所有的k/v对 hgetall 9. 取所有的键的值 hvals key 10. 取键值对的个数 hlen key 11. 取所有键名 hkeys key 12. 判断是否存在k hexists key k list 类型 1. 从左侧添加数据 若key不存在 为其创建一个list lpush key str1,str2……strn 2. 从右侧添加数据 若key不存在 为其创建一个list rpush key str1,str2……strn 3. 查看指定角标之间的元素 角标可为负数，-1为最后一个元素，以此类推 lrange key start,end 4. 弹出左侧第一个元素 lpop key 5. 弹出右侧第一个元素 rpop key 6. 获取列表中元素个数 llen key 7. 向列表头部插入val 仅当key存在时可用 返回值为lit的长度 lpushx key val 8. 删除列表中count个值为val的元素 count>0从头向尾遍历 countset Set 集合中不允许出现重复的元素 使用场景:跟踪一些具有唯一性的数据 1. 添加值、从左端添加 sadd [setname] [value1][value2].. 2. 删除值 srem [setname] [value1][value2].. 3. 查看set集合 smember [setname] 4. 判断值是否存在 返回1存在；0不存在 sismember [setname] [value] 5 .差集运算，[setname1]多余的、注意顺序 sdiff [resultSetName] [setname1] [setname2] 6. 交集运算 sinter [resultSetName] [setname1] [setname2] sortedSet 字符串集合，不允许元素重复。存储元素时需要关联存储一个对应的分数，分数用于排序。元素不可重复但分数可重复。成员在集合中的位置是有序的。 使用场景：排行榜 1. 添加元素 zadd [sortname] [score1][value1][score2][value2] 2. 删除 zrem [sortname] [value] 3. 显示value的分数 zscore [sortname] [value] 4. 查询长度 zcard [sortname] 5. 查询区间内的值、是否返回分数 从小到大 zrange [sorename] [start] [stop] [witchscores] 6. 查询区间内的值、是否返回分数 从大到小 zrange [sorename] [start] [stop] [witchscores] redis 持久化 RDB（默认支持的，不需要配置）：在指定时间间隔内，将内存中的数据和快照写入磁盘 优势：性能最大化,可以开启小的进程处理持久化操作、可以将数据保存为一个文件,便于备份、方便可移植性 劣势：可能会出现数据丢失的问题，在持久化时间没到的时候丢失的数据无法找回、当数据过大,进程处理将会延迟几百秒到一千毫秒 AOF：以日志的形式记录服务器处理的每一个操作，在 redis 服务器启动之初会读取该文件，重新构建数据库，保证启动后数据库中的数据是完整的 优势： 1. 带来更高的数据安全性。有三种同步策略。每秒同步、每修改同步、不同步。 2. AOF 文件是一个只进行追加操作的日志文件，因此在写入过程中即使出现宕机现象也不影响之前已经存在的内容。 3. 如果日志过大，redis可以启动重写机制。在重写过程中产生的对数据库操作记录会保存在一个新文件中，等到重写完成后再追加到现有的文件中。 4. AOF 文件有序地保存了对数据库执行的所有写入操作 劣势： 1. 对于相同数量的数据集而言，文件比rdb方式要大。 2. 效率比rdb低 启用： # 修改redis.conf appendonly yes 同步策略： appendfsync always(每次操作同步，效率低，最安全) appendfsync everysec（每秒同步） appendfsync no（不同步） "},"soft/nodejs/nodejs.html":{"url":"soft/nodejs/nodejs.html","title":"nodejs","keywords":"","body":"nodejs 采用 CommonJS 模块化规范 win 下 npm 全局安装路径 修改配置文件 npmrc(D:\\developer\\nodejs\\node_modules\\npm),添加: prefix=D:\\developer\\nodejs\\node_global cache=D:\\developer\\nodejs\\node_cache 将 prefix 对应路径添加到系统 Path 环境变量 运行.js 文件 命令行运行：node xxx.js npm 命令 npm 是 nodejs 包管理工具 npm init 生成 package.json npm run 自定义命令 运行 package.json(scripts) npm install cnpm -g --registry=http://registry.- npm.taobao.org npm install xxx@xxx -g 全局安装 npm install xxx@xxx -save npm install xxx@xxx --save-dev "},"soft/maven/maven.html":{"url":"soft/maven/maven.html","title":"maven","keywords":"","body":"maven maven 基于项目管理的对象模型(POM),可用一小段描述信息来管理项目的构建、报告和文档的 Java 项目管理工具 安装 设置系统环境变量 M2_HOME(maven 安装目录) 添加 %M2_HOME%/bin到系统变量Path 常用命令 mvn -v mvn test mvn clean mvn compile mvn package -Dmaven.test.skip=true -P 环境变量 mvn install 通过命令行创建项目 mvn archetype:generate maven 中的坐标和仓库 坐标: 用来标识 maven 构件,包含groupId、articleId、version标识. groupId:组织名(网址反写+项目名) articleId:项目名-模块名 仓库: 用来管理项目依赖，包含本地仓库和远程仓库。 修改本地仓库存放地址 修改${maven 安装目录}\\conf\\settings.xml D:/developer/apache-maven-3.3.1/rep maven 镜像仓库 修改${maven 安装目录}\\conf\\settings.xml 阿里云: alimaven central aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ maven 中如何指定 jdk 的版本 全局配置:指在 ${MAVEN_HOME}\\conf\\settings.xml 中进行配置，例如，要配置 jdk1.8, 打开 settings.xml 这个文件，然后在 \\ \\ 之间添加如下代码 jdk1.8 true 1.8 1.8 1.8 1.8 全局配置的好处就是省事、方便。一次配置以后，再使用 maven 构建项目，项目编译 时，默认使用 jdk1.8 进行编译。 局部配置就是只针对具体某个项目进行配置的。具体就是，在项目的 pom.xml 文件中 添加如下代码 org.apache.maven.plugins maven-compiler-plugin 1.7 1.7 maven webapp 项目结构 maven plugins // tomcat org.apache.tomcat.maven tomcat7-maven-plugin 2.2 / 8080 UTF-8 "},"soft/mysql/mysql.html":{"url":"soft/mysql/mysql.html","title":"mysql","keywords":"","body":"mysql 添加到 win 服务 在安装的 bin 目录下创建.bat 文件 @echo off cd /d %~dp0 mysqld.exe --install mysql --defaults-file=\"D:\\developer\\MySQL Server 5.5\\my.ini\" pause 要 cmd 运行一些 mysql 的命令行需要把 bin 目录的路径添加到系统的 Path 环境变量 修改 my.ini default-character-set=utf8 character-set-server=utf8 default-storage-engine=INNODB mysql 命令 mysql -uroot -proot -P3306 -h127.0.0.1// window 控制台中文注释乱码: set names gbk; \\G show full columns from tableName; 查看索引 show index from tableName show keys from tableName 查看存贮过程 show procedure status show create procedure xxxx\\G explain distinct ignore comment join on limit groud by engine current_timestamp(); now(); ifnull(); sum(); count(); max(); 子查询() update business b, (SELECT business_id, COUNT(1) cou FROM `order` WHERE `order`.create_time #{endTime} and `order`.create_time ]]> #{startTime} GROUP BY business_id ) c set b.number = IFNULL(b.number,0) +c.cou where b.id = c.business_id ; 添加用户示例 添加 mysql 用户 travis create user travis@localhost; 授权 grant all privileges on dataBaseName.tableName to travis@localhost; grant all privileges on dataBaseName.* to travis@localhost; 查看 travis 用户的权限 show grants for travis@localhost; mysql 数据库字段接收表情数据 ALTER DATABASE xxxxx CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; "},"soft/nginx/nginx.html":{"url":"soft/nginx/nginx.html","title":"nginx","keywords":"","body":"命令 nginx.exe -t 验证配置 nginx.exe -s reload nginx.exe -s stop 本地调试 需要改 host 文件 windows(C:\\Windows\\System32\\drivers\\etc\\hosts) 格式： ip 域名 关于反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 动静分离 将静态资源部署在 Nginx 上，当一个请求来的时候，如果是静态资源的请求，就直接到 nginx 配置的静态资源目录下面获取资源，如果是动态资源的请求，nginx 利用反向代理的原理，把请求转发给后台应用去处理，从而实现动静分离。 负载均衡 轮询/权重/iphash nginx 配置 被调用方支持跨域 server{ listen 80; server_name \"b.com\"; location /{ proxy_pass http://localhost:8080; add_header Access-Control-Request-Method *; add_header Access-Control-Max-Age 3600; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Origin $http_origin; add_header Access-Control-Allow-Headers $http_access_control_request_headers; if ($request_method = OPTIONS){ return 200; } } } "},"soft/lombok/lombok.html":{"url":"soft/lombok/lombok.html","title":"lombok","keywords":"","body":"lombok logback 是 java 的一个开源的日志框架,它提供了两个日志框架的日志，一个是 Log4j 一个是 Logback。 jd-gui 反编译，查看生成后的源码。 ide 安装 idea 安装 lombok 插件 eclipse 命令行:java -jar lombok.jar 选择 eclipse 安装目录 项目引入 lombok 依赖 org.projectlombok lombok provided lombok 注解 "},"soft/en/english.html":{"url":"soft/en/english.html","title":"常用单词","keywords":"","body":"常用单词 A and add answer auto B begin boolean border bottom background C config content contentType context ContextConfiguration count commit components compile clean checkout comment charset constant D developer development default data database date double datetime deny discard deploy drop E execute end engine F format favicon font focus flush exist G global H height I ignore insert indent import init install increment int J join K key L link M margin member N number now null O on P param project properties production padding package port plugin push pull permission primary Q query question R result run rollback remote remove repository reload S serializble success select start set src size skip settings state status stage T transient then table timestamp test title tutorial U unique V version vaule validate varchar W while width weight X Y value Z "},"java/":{"url":"java/","title":"Java docs","keywords":"","body":"Java docs "},"java/javaweb.html":{"url":"java/javaweb.html","title":"java web","keywords":"","body":"Java Web 相关 maven 依赖： javax.servlet javax.servlet-api 3.0.1 provided taglibs standard 1.1.2 jstl jstl 1.2 servlet3.0 web.xml: index.jsp JSP JSP 简介: 全名 Java server pages，其根本是一个简化的 servlet 设计，他实现了在 Java 中使用 HTML 标签。JSP 是一种动态网页技术标准也是 javaee 的标准。和 servlet 一样在服务端运行。 JSP 语法 JSP 指令: page 指令: page指令: taglib指令: 引入 JSTL 标签库 include指令: 引入共通的 JSP 页面,最后编译成一个 Servlet 示例：引入(WEB-INF/jsp/common/header.jsp) header.jsp: 在别的 JSP 页面引入： 针对所有JSP的全局引入： 在 web.xml 添加配置 *.jsp /WEB-INF/jsp/common/header.jsp JSP 注释： html 注释： 客户端可见 客户端不可见 jsp 脚本注释（客户端不可见）： //单行注释 /**/多行注释 JSP 脚本： 在 JSP 页面中执行的 java 代码。语法： JSP 声明： 语法： JSP表达式: 目的是获得(表达式结果|已定义变量的值)，语法：, 引用basePath变量： \"> index.jsp JSP 页面生命周期 jspService()用来处理客户端的请求。 对每一个请求，JSP 引擎创建一个新的线程来处理该请求。每个客户端请求对应一个线程。 如果有多个客户端同时请求该 JSP 文件，则 JSP 引擎会创建多个线程。以多线程方式执行可以大大降低对系统的资源需求，提高系统的并发量及响应时间。但也要注意多线程的编程带来的同步问题，由于该 Servlet 始终驻于内存，所以响应是非常快的。 JSP 九大内置对象 jsp 内置对象：web 容器创建的一组对象，不使用 new 就可以使用的内置对象 out out 对象:是 JSPWriter 类的实例，是向客户端输出内容常用的对象。 request 客户端的请求信息被封装在 request 对象中，通过它才能了解到客户的需求，然后做出响应。它是 HttpServletRequest 类的实例。request 对象具有请求域，即完成客户端的请求之前，该对象一直有效。 response response 对象包含了响应客户请求的有关信息。它是 HttpServletResponse 类的实例。response 对象具有页面作用域,即访问一个页面时，该页面内的 response 对象只能对这次访问有效,其他页面的 response 对象对当前页面无效。 获取输出流对象PrintWriter response.getWriter() session session 表示客户端与服务器的一次会话，是 HttpSession 类的实例。web 中的 session 指的是用户在游览某一个网络时从进入网站到游览器关闭所经过的这段时间，也就是用户游览这个网站所花费的时间，session 实际上时一个特定的时间概念. 在服务器的内存中保存着不同用户的 session web.xml 设置 session 超时时间 1 application ServletContext 类的实例；实现用户间数据的共享，可存放全局变量，开始于服务器的启动，终止于服务器的关闭，在用户的前后连接或不同用户之间的连接，可以对 application 对象的同一属性进行操作；在任何地方对 application 对象属性的操作都会影响到其他用户对此的访问；服务器的启动和关闭决定了 application 对象的声明 page page 对象就是指向当前 jsp 页面本身 pageContent pageContext 对象提供了对 JSP 页面内所有对象及名字空间的访问 pageContext 对象可以访问本页所在的 session,也可以取本页面所在的 application 的某一属性值。pageContext 对象相当于页面中的所有功能的集大成者。pageContext 对象的本类名也叫 pageContext。 exception Exception 对象：异常对象,java.lang.Throwable 的对象，若一个 JSP 页面要应用此对象，必须把 isErrorPage 设为 true 否则无法编译。 config config 对象是在一个 Servlet 初始化时,JSP 引擎向它传递信息用的,此信息包括 Servlet 初始化时所要用到的参数(通过属性名和属性值构成)以及服务器的有关信息(通过传递一个 ServletContext 对象) 请求转发与请求重定向之间的区别 请求转发：服务器行为，request.getDispatcher().forward(req,resp);是一次请求，相当于在前一个地址进行的，转发后请求对象内容会保存，地址栏 url 地址不会改变（即为前一个地址） 请求重定向：客户端行为，resonse.sendRedirect().其实相当于两次请求，前一次的请求对象不会保存，地址栏 url 会改变（新页面） cookie cookie 是 web 服务器保存在客户端的一系列文本信息 创建 Cookie 对象: Cookie newCookie=new Cookie（String key,Object value）; 写入 Cookie 对象: response.addCookie(newCookie); 读取 Cookie 对象: Cookie[] cookies=request.getCookies(); JSP 常用标签 JSTL JSTL 是 java 中的一个定制标记库集. 在 JSP 页面使用taglib指令引入。 示例： \" pattern=\"yyyy-MM-dd HH:mm:ss\"> username:${user.name }&nbsp;&nbsp;&nbsp;&nbsp;age:${user.age} ${item.key} ${item.value} JSP2.0 自定义标签 .tag文件： 示例： (WEB-INF/tags/hasAnyPermission.tag) 引入自定义标签 使用hasAnyPermission.tag 语法： You have one of permissions{*,user:update} EL 表达式: Exoression Language, 功能与 JSP 表达式一样,经常与 JSTL 配合使用，使得 JSP 页面更直观，写法更简单。变量要存放到 JSP 的内置对象里。 语法：${表达式|变量}。 ${RequestScope.name} JSP内置对象在EL表达式中名称： JSP 内置对象 EL 名称 Page PageScope Request RequestScope Session SessionScope Application ApplicationScope EL 表达式不限定范围会默认按 Page->Request->Session->Application顺序查找。 EL运算符： 类别 运算符 算术运算符 +,-,*,/,% 关系运算符 ==,!=,>,=, 逻辑运算符 `&&, ,!` 验证运算符 empty Servlet Servlet 是在服务器上运行的小程序。一个 Servlet 就是一个 java 类，并且可以通过“请求-响应”编程模型来访问的这个驻留在服务器内存里的 Servlet 程序 编写 servlet 步骤： 继承 HttpServlet 重写 doGet()或者 doPost() 方法 在 web.xml 中注册 Servlet 在 web.xml 配置 Servlet helloServlet com.imooc.servlet.HelloServlet param helloServlet 1 helloServlet /helloServlet Servlet 执行流程和生命周期 Tomcat 装载 Servlet 的三种情况 在 web.xml 文件中的之间添加1 会在服务器启动时加载 servlet， 数字越小优先级越高 首次访问 Servlet，服务器会加载 Servlet servlet 类被修改的时候，也会自动装载 servlet 与九大内置对象 Filter 过滤器 过滤器是一个服务器端的组件，它可以截取用户端的请求和响应信息，并对这些信息过滤 Filter 过滤器的生命周期 实例化和初始化init()只执行一次（服务器启动时），doFilter() 每次拦截请求都执行 编写 Filter 步骤： 实现javax.servlet.Filter接口 重写三个方法init() doFilter() destroy()方法 init()初始化：这个方法可以读取 web.xml 文件中的过滤器初始化参数。通过参数FilterConfig对象可以获取更多参数 doFIlter()核心：完成实际的过滤操作。 在web.xml配置过滤器 Filter 过滤器链 Filter 分类 request forward include error @webfilter注解 Listener 监听器 Web 监听器由 Servlet 规范提供的,可以监听客户端的请求以及服务端的操作,即监听 ServletContext、HttpSession、ServletRequest 对象.监听事件分为这三个对象的创建、销毁事件以及这三个对象属性的变化事件.可以在事件发生前后做一些处理。 创建 Web 监听器 步骤： 创建一个实现监听器接口的类 配置 web.xml 进行监听器注册(或者使用@WebListener注解) 监听器|过滤器|servlet 启动顺序 加载顺序：监听器>过滤器>servlet 监听器分类 按监听器的对象划分： 监听(实现ServletContextListener接口)应用程序环境对象(ServletContext)的事件监听器 监听(实现HttpSessionListener接口)用户会话对象(HttpSession)的事件监听器 监听(实现ServletRequestListener接口)请求消息对象(ServletRequest)的事件监听器 ServletContextListener代码： param hello world import lombok.extern.slf4j.Slf4j; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; @Slf4j public class contextListener implements ServletContextListener { public contextListener() { log.info(\"contextListener()\"); } // ServletContext创建时调用 @Override public void contextInitialized(ServletContextEvent sce) { log.info(\"contextInitialized\"); String param = sce.getServletContext().getInitParameter(\"param\"); if (param != null) { log.info(\"ServletContext 获得初始化参数 param={}\", param); } } // ServletContext销毁时调用 @Override public void contextDestroyed(ServletContextEvent sce) { log.info(\"contextDestroyed\"); } } HttpSessionListener: import lombok.extern.slf4j.Slf4j; import javax.servlet.http.HttpSession; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; @Slf4j public class SessionListener implements HttpSessionListener { public SessionListener() { log.info(\"SessionListener()\"); } // session创建时调用 @Override public void sessionCreated(HttpSessionEvent se) { HttpSession session = se.getSession(); log.info(\"产生一个session id={}\",session.getId()); } // session 销毁时调用 @Override public void sessionDestroyed(HttpSessionEvent se) { HttpSession session = se.getSession(); log.info(\"销毁session id={}\",session.getId()); } } ServletRequestListener: 监听 http 请求 package com.imooc.listener; import lombok.extern.slf4j.Slf4j; import javax.servlet.ServletRequestEvent; import javax.servlet.ServletRequestListener; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServletRequest; @Slf4j public class RequestListener implements ServletRequestListener { public RequestListener() { log.info(\"RequestListener()\"); } @Override public void requestInitialized(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre.getServletRequest(); Cookie[] cookies = request.getCookies(); boolean JSESSIONID_exist = false; String JSESSIONID = null; if (cookies != null && cookies.length > 0) { for (Cookie cookie : cookies) { if (!\"JSESSIONID\".equals(cookie.getName())) { continue; } JSESSIONID_exist = true; JSESSIONID = cookie.getValue(); } } if (JSESSIONID_exist) { log.info(\"产生一个request url={},JSESSIONID={}\", request.getServletPath(), JSESSIONID); } else { log.info(\"产生一个request url={}\", request.getServletPath()); } } @Override public void requestDestroyed(ServletRequestEvent sre) { HttpServletRequest request = (HttpServletRequest) sre.getServletRequest(); Cookie[] cookies = request.getCookies(); boolean JSESSIONID_exist = false; String JSESSIONID = null; if (cookies != null && cookies.length > 0) { for (Cookie cookie : cookies) { if (!\"JSESSIONID\".equals(cookie.getName())) { continue; } JSESSIONID_exist = true; JSESSIONID = cookie.getValue(); } } if (JSESSIONID_exist) { log.info(\"完成和销毁一个request url={},JSESSIONID={}\", request.getServletPath(), JSESSIONID); } else { log.info(\"完成和销毁一个request url={}\", request.getServletPath()); } } } WEB 资源目录 WEB 资源目录在 maven-webapp 工程里为webapp(src/main/webapp)目录,是 WEB 工程发布的根目录，打包时webapp下的所有资源会被打包到工程名.war文件。war 文件可直接放到tomcat服务器的webapps下启动，此时访问 web 应用需要带上 web 工程名(如:http://localhost:8080/web工程名)。将 war 文件重命名为ROOT.war可直接通过(http://localhost:8080/)访问。 war 文件的 WEB-INF 目录结构 classes 存放 java 编译后生成的.class文件 lib 存在 maven 依赖的 jar 获取 web 应用的上下文路径 web 应用可以发布到 tomcat 的根目录或者加上项目名；加上项目名的 web 应用需要使用/web工程名/xxxx才能访问真实的映射路径。 下面的代码能获取 web 应用发布的根路径： Java 实现文件上传下载 上传原理 将表单元素设置Method=\"POST\" enctype=\"multipart/form-data\"属性，让表单数据以二进制编码的方式提交，在 Servlet 中获取二进制流。 请求头的 Content-Type:multipart/form-data;boundary=-------一堆数字字符， boundary 是文件内容分割线。 文件下载原理 设置响应头的ContentType字段为application/octet-stream或者application/msdownload HttpServletResponse.setContentType() HttpServletResponse.setHeader(\"Content-Disposition\",\"attachment;filename=文件名\") HttpServletResponse.getOutputStream()获取 ServletOutputStream 对象，输出文件内容。 "},"java/synchronized.html":{"url":"java/synchronized.html","title":"synchronized","keywords":"","body":"synchronized 深度解析 synchronized 简介 能够保证在同一时刻最多只有一个线程执行该代码段，以保证并发安全的效果。 多线程访问同步方法的几种情况 同时访问同一个对象的同步方法 锁定当前对象，不同线程竞争同一把锁，同一时刻只能有一个线程执行同步方法 不同线程访问不同对象的同步方法 锁定的不是同一对象，不相互影响执行过程 不同线程访问同步(synchronized)的静态(static)方法 锁定当前类，不同线程会顺序执行同步方法 可见性原理 "},"java/diary.html":{"url":"java/diary.html","title":"diary","keywords":"","body":"diary 看源码的能力 提高编码的能力 写文档的能力 学会框架上解决问题的思维与常用手段 实战和学习是相互促进的 2019/1/1 先设计业务模型，再设计数据库模型。 2019/1/14 通过教程来学习新的知识;教程侧重实用,边幅简短。 "},"spring/":{"url":"spring/","title":"Spring","keywords":"","body":"简介 Spring 是为解决企业应用程序开发复杂性而创建的一个 Java 开源框架，应用非常广泛。 "},"spring/springmvc.html":{"url":"spring/springmvc.html","title":"springmvc","keywords":"","body":"SpringMVC SpringMVC 工作流程 org.springframework.web.servlet.DispatcherServlet 其实就是个 Servlet ,需要在web.xml配置文件下声明,把希望由 DispatcherServlet 处理的请求映射到对应的 URL 上。 默认配置文件-serlvet.xml放在WEB-INF目录下;可以通过contextConfigLocation参数改变文件指向。 web.xml配置例子: springmvc org.springframework.web.servletDispatcherServlet contextConfigLocation classpath:spring/spring-web.xml 1 springmvc / SpringMVC 动态概念: SpringMVC 上下文 Root WebApplicationContext WebApplicationContext for namespace 'servletName' 在web.xml配置Root WebApplicationContext: org.springframework.web.context.ContextLoaderListener contextConfigLocation classpath:spring/applicationContext.xml SpringMVC 处理 Form 表单提交 restful 请求 Form 表单只支持 GET 和 Post 方式，添加org.springframework.web.filter.HiddenHttpMethodFilter过滤器可以让 Form 表单提交PUT和DELETE请求，需要在 Form 表单添加_method参数。 SpringMVC 处理 Form 表单提交带文件上传的 restful 请求 Form 表单的 enctype=\"multipart/form-data\";需要先获取文件输入流,再解析表单参数。org.springframework.web.multipart.support.MultipartFilter的顺序在前， org.springframework.web.filter.HiddenHttpMethodFilter在后。 CommonsMultipartResolver: 放在 Spring 的根上下文;org.springframework.web.multipart.support.MultipartFilter#lookupMultipartResolver()方法将从根上下文获取CommonsMultipartResolver,获取不到则使用默认的org.springframework.web.multipart.support.StandardServletMultipartResolver web.xml: CharacterEncodingFilter org.springframework.web.filterCharacterEncodingFilter encoding UTF-8 CharacterEncodingFilter /* MultipartFilter org.springframework.web.multipart.support.MultipartFilter multipartResolverBeanName multipartResolver MultipartFilter /* HiddenHttpMethodFilter org.springframework.web.filter.HiddenHttpMethodFilter HiddenHttpMethodFilter /* SpringMVC 配置 @Value: 在Controller中使用@Value(\"${key}\") 需要 SpringMVC 单独加载配置文件。 开启SpringMVC注解驱动: 会自动注册 DefaultAnnotationHandlerMapping 与 AnnotationMethodHandlerAdapter 两个 bean,是 SpringMVC 为@Controller 分发请求所必须的。 并提供了：数据绑定支持，@NumberFormatannotation 支持，@DateTimeFormat 支持，@Valid 支持，读写 XML 的支持（JAXB），读写 JSON 的支持（Jackson）。 处理静态资源: 优雅 REST 风格的资源 URL 不希望带 .html 或 .do 等后缀.由于早期的 Spring MVC 不能很好地处理静态资源，所以在 web.xml 中配置 DispatcherServlet 的请求映射，往往使用 .do 、 .xhtml 等方式。这就决定了请求 URL 必须是一个带后缀的 URL，而无法采用真正的 REST 风格的 URL。如果将 DispatcherServlet 请求映射配置为\"/\"，则 Spring MVC 将捕获 Web 容器所有的请求，包括静态资源的请求，SpringMVC 会将它们当成一个普通请求处理，因此找不到对应处理器将导致错误。 会在 SpringMVC 上下文中定义一个 org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，它会像一个检查员，对进入 DispatcherServlet 的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由 DispatcherServlet 继续处理。一般 Web 应用服务器默认的 Servlet 名称是\"default\"，因此 DefaultServletHttpRequestHandler 可以找到它。如果你所有的 Web 应用服务器的默认 Servlet 名称不是\"default\"，则需要通过 default-servlet-name 属性显示指定： 将静态资源的处理经由 SpringMVC 框架交回 Web 应用服务器处理。而更进一步，由 SpringMVC 框架自己处理静态资源，并添加一些有用的附加值功能。 允许静态资源放在任何地方，如 WEB-INF 目录下、类路径下等，你甚至可以将 JavaScript 等静态文件打到 JAR 包中。通过 location 属性指定静态资源的位置，由于 location 属性是 Resources 类型，因此可以使用诸如\"classpath:\"等的资源前缀指定资源位置。传统 Web 容器的静态资源只能放在 Web 容器的根路径下，完全打破了这个限制。 在 Maven Webapp 工程中src/main/webapp是 Web Resource Directory. 返回JSP页面: Controller 方法处理完成后返回 String 字符串默认指向视图页面;数据可以保存在org.springframework.ui.Model对象中,在页面中通过 EL 表达式(${key})获取;重定向和转发是返回\"forward:\"或者\"redirect:\"加上映射路径。 SpringMVC 拦截器 实现org.springframework.web.servlet.HandlerInterceptor接口 拦截器链： 拦截器映射路径： 拦截器配置例子: 按顺序执行,可以对映射 url 进行排除。 SpringMVC 相关注解 @org.springframework.stereotype.Controller 注解类 org.springframework.web.bind.annotation.RestController 注解类 @org.springframework.web.bind.annotation.RequestMapping 注解类或者方法,可以指定映射路径和请求的类型 @org.springframework.web.bind.annotation.RequestParam 注解参数，通过?key=value方式传值。 @org.springframework.web.bind.annotation.PathVariable 注解参数,获取 url 对应占位符上的值。 @RequestMapping(value = \"/detail/comment/{pageNum}/{id}\", method = RequestMethod.GET) public CommentListDto commentList(@PathVariable(\"pageNum\") Integer pageNum, @PathVariable(\"id\") Integer id) { return businessService.getCommentList(id, pageNum + 1, 10); } org.springframework.web.bind.annotation.ResponseBody 将 Controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 response 对象的 body 区，通常用来返回 JSON 数据或者是 XML.在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过 response 对象输出指定格式的数据. @org.springframework.web.bind.annotation.ControllerAdvice 配合org.springframework.web.bind.annotation.ExceptionHandler进行全局异常处理。 @ControllerAdvice @Slf4j public class ExceptionResolver { public static final String ERROR_VIEW_NAME = \"system/error\"; // 可以返回 ModelAndView @ExceptionHandler(value = Exception.class) public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Exception e) { log.error(\"哪里出错了...\", e); if (isAjax(request)) { ModelAndView jsonView = new ModelAndView(new MappingJackson2JsonView()); jsonView.addObject(\"url\", request.getRequestURI()); jsonView.addObject(\"errMsg\", e.getMessage()); return jsonView; } else { ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"url\", request.getRequestURI()); modelAndView.addObject(\"errMsg\", e.getMessage()); modelAndView.setViewName(ERROR_VIEW_NAME); return modelAndView; } } public boolean isAjax(HttpServletRequest request) { return (request.getHeader(\"X-Requested-With\") != null && \"XMLHttpRequest\" .equals(request.getHeader(\"X-Requested-With\").toString())); } } "},"spring/databinding.html":{"url":"spring/databinding.html","title":"springmvc 数据绑定","keywords":"","body":"SpringMVC 实现多种数据类型绑定 绑定基本数据类型 Java 基本数据类型 int 的默认值是 0，在使用 int 进行 url 传递参数时，参数 key 是必须写的，其值也只能是 int 类型的，否则将会报错。 比如方法： @RequestMapping(value = \"baseType.do\") @ResponseBody //返回的数据放到 ResponseBody 的数据区中 public String baseType(int age){ return \"age:\"+age; } 请求的 url 地址：http://localhost:8080/baseType.do?age=10，其中参数age是必传的，其值只能是int类型的； 如果不传，将会报 500 错误。 比如： http://localhost:8080/baseType.do 如果传递了，但是数据类型是其他类型，将会报 400 错误，比如： http://localhost:8080/baseType.do?age=abc 又比如方法： @RequestMapping(value=\"baseType1.do\") @ResponseBody public String baseType1(@RequestParam(value=\"xage\")int age){ return \"age: \" + age; } 我们可以使用@RequestParam 注解来为传入的参数，定义一个别名参数， @RequestParam（value=\"\",required = true）value 参数别名 required 该参数是否必传，默认为 true； 访问的 url 地址如下： http://localhost:8080/baseType1.do?xage=10 同样 xage 这个参数也是必传的，其类型为 int。 如果是其他基本数据类型也是如此，其中 byte,short,int 的默认值都为 0，long 的默认值为 0L,float 的默认值为 0.0f，double 的默认值为 0.0d 在进行数据绑定时，其参数值必传，其值的类型为其对应的基本数据类型。 绑定包装数据类型 Java 封装类型 Integer 的默认值为 null，在使用 Integer 进行 url 数据传递时，参数 key 可以不传，对应参数的值就会默认为 null。 比如方法： @RequestMapping(value = \"baseType2.do\") @ResponseBody public String baseType2(Integer age){ return \"age:\"+age; } 其 url 地址参数 age 可以不传，也可以传，对应的 url 地址如下： http://localhost:8080/baseType2.do?age=10 http://localhost:8080/baseType2.do 但是如果传递了 age 参数，其值为其他数据类型，将会报 400 错误，比如： http://localhost:8080/baseType2.do?age=abc 数据绑定的数值型接受参数可以是基本类型和包装类型，但二者有区别： 基本类型不可接受空值，会报错。且输入数值必须在指定数据类型的数据范围内 包装类型则可以接受空值，具有优势，推荐使用，比如传递的参数是年龄、身高、长度、宽度等，具体情况可根据业务需要进行变更 绑定数组类型 Java 数组：它是一个具有相同数据类型，固定大小的对象。 绑定数组类型的方法如下： @RequestMapping(value = \"array.do\") @ResponseBody public String array(String[] name){ StringBuilder sbf = new StringBuilder(); StringBuffer sb = new StringBuffer(); for(String item : name){ sbf.append(item).append(\" \"); } return sbf.toString(); } 在使用 url 地址传递参数时，一次可以传递多个参数值，值与值之间使用&分开，如下： http://localhost:8080/array.do?name=Tom&name=Lucy&name=Jim 绑定对象类型 这里以绑定 User 对象为例，绑定的方法如下： @RequestMapping(value=\"/user\") @ResponseBody public String GetUser(User user){ return user.toString(); } 使用 url 传递参数的方式如下： http://localhost:8080/user?name=Tom&age=10 其中 name、age 都是 User 对象的属性。 对象类型的数据绑定，直接请求时对应其属性即可，不必添加前缀，如 User 类的属性 name，则直接在请求中使用 name=xxx，而不是使用 user.name=xxx 的形式。url 如下： http://localhost:8080/user?name=Tom&age=10 但如果是想对对象中对象的属性再赋值的话，则需要使用 xxx.xxx 的形式，如下的 contactInfo.phone 表示将 User 类中的 ContactInfo 类的 phone 属性赋值。 如下： http://localhost:8080/object.do?name=Tom&age=10&contactInfo.phone=10086 两个对象同属性进行数据绑定 这里以 User 对象和 Admin 对象为例，这两个对象具有相同的属性 name，age，这两个对象进行数据绑定的方法如下： @RequestMapping(value = \"object.do\") @ResponseBody public String object(User user,Admin admin){ return user.toString()+\" \"+admin.toString(); } 在这里是有 Spring 注解@InitBinder 来初始化一个对象。 对于两个不同的类，遇到同名属性的情况，SpringMVC 会默认针对所有类的同名属性赋值，如下面 url 传递的 name，age 参数将是两个对象共有的： http://localhost:8080/object.do?name=Tom&age=10 如果想要区别对待，直接使用 xxx.xxx 的形式是不行的，还需要在对应的 Controller 中定义方法，以 @InitBinder 注解标记属性名，形参使用 WebDataBinder 来定义请求参数前缀，若没加前缀则是共有的。方法定义如下： @InitBinder(\"user\") //@InitBinder 初始化一个对象 public void initUser(WebDataBinder binder){ binder.setFieldDefaultPrefix(\"user.\"); } @InitBinder(\"admin\") public void initAdmin(WebDataBinder binder){ binder.setFieldDefaultPrefix(\"admin.\"); } 使用 url 传递参数，如下： http://localhost:8080/object.do?user.name=Tom&admin.name=Lucy&age=10 其中 age 参数是两个对象共用的。 绑定 List 对象 Java 中 List 集合类型：List 是一个有序，可重复的的线性表。 在绑定 List 对象数据时，首先要将对象封装为 List 对象，并设置它的 get/set 方法，以 User 对象为例，封装如下： private List users; 然后 controller 下对应的方法定义如下： @RequestMapping(value = \"list.do\") @ResponseBody public String list(UserListForm userListForm){ return \"listSize:\"+userListForm.getUsers().size() + \" \" + userListForm.toString(); } 其中 UserListForm 是封装的 List 对象类，使用 url 传递参数的方式如下： http://localhost:8080/list.do?users[0].name=Tom&users[1].name=Lucy Controller 中 List 参数不能直接传值，需要一个包裹类，类中有需要传的 List 作为属性和对应的 get,set 方法。 传值时用 users[0].name = Tom users[1].name = Luce 一定不要跳跃传值，如 users[0].name = Tom&users[20].name = Lucy 这样中间的 1~19 也会占用资源属性值为空。 http://localhost:8080/list.do?users[0].name=Tom&users[1].name=Lucy&users[20].name=Jim 绑定 Map 对象 Java 中 Map 集合对象：Map 是一个基于 kay-value 键值对的集合类型，它是无序的，其中键 key 不可重复，值 value 可以重复。 在绑定 Map 对象数据时，首先要将对象封装为 Map 对象，并设置它的 get/set 方法，以 User 对象为例，封装如下： private Map users; 然后 controller 下对应的方法定义如下： @RequestMapping(value = \"map.do\") @ResponseBody public String map(UserMapForm userMapForm){ return userMapForm.toString(); } 其中 UserMapForm 是封装的 Map 对象，使用 url 传递参数的方式如下： http://localhost:8080/map.do?users[‘X’].name=Tom&users[‘X’].age=10&users[‘Y’].name=Lucy 其中 X,Y 是 key，类型是 String 类型。 绑定 Set 对象 Java 中 Set 集合对象：Set 集合无序，且不可重复，因为它重写了 hashCode()方法和 equals()方法； Set 集合在实际的应用中，常用于对象的重复判断或者排除重复。 在 SpringMVC 中绑定 Set 数据类型，接口的参数形式和绑定 list 是类似的，都是通过索引。但是不同的在于，Set 必须初始化，它必须先包含了初始化对象，也即是说必须提前手动分配好空间，才能进行赋值，而使用 List 则没有这个要求。 另外的一个坑在于，初始化 Set 时需要留意对象的 equals 方法，假如我们在提前分配两个对象空间时，两个对象通过 equals 方法判断为相同，则我们期望的 Set 的 size 为 2，最后实际因为去重变成了 1，导致在数据绑定时很容易出现数组越界的异常。 Set 集合类型：我们一般用来排重 使用 Set 的时候需要先进行初始化 要使用 Set 的排重功能必须在对象中覆写 hashcode 和 equals 方法。 SpringMVC 对 Set 支持并不太好，初始化进行排重时会导致 size 变小，致使无法接受更多的数据而抛出异常，所以我们开发一般优先使用 List。 在绑定 Set 对象数据时，首先要将对象封装为 Set 对象，并设置它的 get/set 方法，并提供构造方法，封装如下： private Set users; private UserSetForm(){ users = new LinkedHashSet(); users.add(new User()); //定义两个对象 users.add(new User()); } 其次还要重写 User 对象的 hashCode()方法和 equals()方法 然后 controller 下对应的方法定义如下： @RequestMapping(value = \"set.do\") @ResponseBody public String set(UserSetForm userSetForm){ return userSetForm.toString(); } 其中 UserSetForm 是封装的 Set 对象，使用 url 传递参数的方式如下： http://localhost:8080/set.do?users[0].name=Tom&users[1].name=Lucy 且不可跳范围传值，如下： http://localhost:8080/set.do?users[0].name=Tom&users[20].name=Lucy 将会报错。 绑定 XML 对象 Java 绑定 XML 对象：XML 是一种扩展标记语言，常用来存储或传输数据。 对于 xml 类型的数据绑定，需要在方法形参上增加注解 @RequestBody，并且在 Post 请求时请求头为 Content-Type: application/xml。 这样 SpringMVC 就会调用对应的解析器去解析，所以我们同时还需要在 pom 中添加 xml 解析的相关依赖 spring-oxm ，如下： org.springframework spring-oxm 将 xml 对应的实体类进行注解标注，根节点放在类名，并使用 name 属性设定对应的 xml 中的根节点名称，其他节点同理。 对于 Admin 对象的 name，age 属性定义为 xml，格式如下： Jime age xml 数据绑定： 必须在实体类里面加注解@XmlRootElement,在属性上添加 XmlElement。定义如下： @XmlRootElement(name=\"admin\") public class Admin { private String name; private Integer age; @XmlElement(name=\"name\") public String getName() { return name; } public void setName(String name) { this.name = name; } @XmlElement(name=\"age\") public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"Admin{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } ex:@XmlElement(name=“age”):此时就会将 xml 里面对应的 age 数据添加到实体类中的 age 属性中去。 然后 controller 下对应的方法定义如下： @RequestMapping(value = \"xml.do\") @ResponseBody public String xml(@RequestBody Admin admin){ return admin.toString(); } url 请求地址为： http://localhost:8080/xml.do, 请求头为 Content-Type: application/xml. $.ajax 发送 xml: var xmlStr = '' +'cc20'; $.ajax({ type: \"POST\", url: \"http://localhost:8080/xml.do\", dataType: \"json\", contentType: \"application/xml;charset=utf-8\", data: xmlStr, success: function (response) { console.log(response); }, error: function (error) { alert(error.statusText) } }); 绑定 Json 对象 JSON 是轻量级的文本数据交换格式,常用于存储和交换文本信息。 SpringMVC 接受 http 中 body 的 json 格式内容为参数，在方法的形参前加上注解 @RequestBody，用以调用解析器进行转换。@ResponseBody返回 JSON 数据。 controller 中方法定义如下： @RequestMapping(value = \"json.do\") @ResponseBody public String json(@RequestBody User user){ return user.toString(); } url 请求地址为： http://localhost:8080/json.do http 请求头：Content-Type: application/json。 $.ajax 发送 json: $.ajax({ type: \"POST\", url: \"http://localhost:8080/json.do\", dataType: \"json\", contentType: \"application/json;charset=utf-8\", data: JSON.stringify({ username: \"Curry\", password: \"123456\" }), success: function (response) { console.log(response); }, error: function (error) { alert(error.statusText) } }); 数据类型转换 Spring3 之前 org.springframework.web.bind.WebDataBinder 使用 java.beans.PropertyEditor 将请求(字符串)转化为 Bean Spring3 之后,类型转换由 org.springframework.core.convert.converter.Converter 完成,格式化由 org.springframework.format.Formatter 完成。 String 字符串转 Date 日期格式示例： 下面的方法只在当前 Controller 有效 @RequestMapping(value = \"/date\") @ResponseBody public String date(Date birthday) { return birthday.toString(); } @InitBinder(\"birthday\") public void initBinder(ServletRequestDataBinder binder){ SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true); } String 字符串转 Date 日期格式全局配置的方法： 方法一: 定义一个实现org.springframework.core.convert.converter.Converter接口的日期的转换类 package com.imooc.common; import org.springframework.core.convert.converter.Converter; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class MyDateConverter implements Converter { @Override public Date convert(String source) { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); try { return sdf.parse(source); } catch (ParseException e) { e.printStackTrace(); } return null; } } 在 Spring xml 配置文件中注入org.springframework.format.support.FormattingConversionServiceFactoryBean对象 方法二： 定义实现org.springframework.format.Formatter接口的日期格式化类 package com.imooc.common; import org.springframework.format.Formatter; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.util.Locale; public class MyDateFormatter implements Formatter { @Override public Date parse(String text, Locale locale) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); return sdf.parse(text); } @Override public String print(Date object, Locale locale) { return null; } } 在 Spring xml 配置文件中注入org.springframework.format.support.FormattingConversionServiceFactoryBean对象 "},"spring/validator.html":{"url":"spring/validator.html","title":"spring validator","keywords":"","body":"使用 spring validator 校验数据 JSR-303 JSR-303 是 Java 为 Bean 数据合法性校验提供的标准框架，它定义了一套可标注在成员变量，属性方法上的校验注解。 Hibernate Validation 提供了这套标准的实现，在 springboot 工程里 spring-boot-starter-web 或者 Spring boot starter validation 的时候，默认会引入 hibernate-validator。 org.hibernate hibernate-validator javax.validation.Valid 注解参数对象 org.springframework.validation.annotation.Validated 注解参数对象(和上面的注解效果一样) org.springframework.validation.BindingResult 对象接收被@Valid 校验不通过的错误信息 示例代码： 实体类 package com.imooc.validator.model; import com.imooc.validator.annotation.IsMobile; import org.hibernate.validator.constraints.Email; import org.hibernate.validator.constraints.NotBlank; import javax.validation.constraints.Min; public class Girl { @NotBlank(message = \"姓名不能为空串\") private String name; @Min(value = 18, message = \"age要大于18\") private Integer age; @IsMobile() private String phone; @Email(message = \"email不正确\") private String email; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } } 通过注解校验 // @Valid 这个是用来接收参数的时候验证的，将验证结果存入 BindingResult 结果中 // http://localhost:8080/valid/test1?name=assds&age=16 @RequestMapping(value = \"/test1\") public Girl test(@Validated Girl girl, BindingResult bindingResult) throws Exception { if (bindingResult.hasErrors()) { log.info(bindingResult.getFieldError().getDefaultMessage()); throw new Exception(bindingResult.getFieldError().getDefaultMessage()); } return girl; } 常见的校验注解 用来注解对象属性 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 提供的校验注解： @NotBlank(message =) 验证字符串非 null，且长度必须大于 0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 自定义注解 完成一些自定义的校验功能。 需要定义一个注解，还有一个完成校验功能的类(实现javax.validation.ConstraintValidator接口) 示例代码： IsMobile 注解 package com.imooc.validator.annotation; import javax.validation.Constraint; import javax.validation.Payload; import java.lang.annotation.Documented; import java.lang.annotation.Retention; import java.lang.annotation.Target; import static java.lang.annotation.ElementType.*; import static java.lang.annotation.ElementType.PARAMETER; import static java.lang.annotation.RetentionPolicy.RUNTIME; @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER }) @Retention(RUNTIME) @Documented @Constraint(validatedBy = {IsMobileValidator.class}) //注解的实现类。 public @interface IsMobile { //校验错误的默认信息 String message() default \"手机号码格式有问题\"; //是否强制校验 boolean isRequired() default false; Class[] groups() default {}; Class[] payload() default {}; } IsMobileValidator 完成校验手机功能 package com.imooc.validator.annotation; import com.imooc.validator.annotation.IsMobile; import org.apache.commons.lang3.StringUtils; import javax.validation.ConstraintValidator; import javax.validation.ConstraintValidatorContext; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * Created by Administrator on 2018/12/8 0008. */ public class IsMobileValidator implements ConstraintValidator { private boolean required = false; private static final Pattern mobile_pattern = Pattern.compile(\"1\\\\d{10}\"); //工具方法，判断是否是手机号 public static boolean isMobile(String src) { if (StringUtils.isEmpty(src)) { return false; } Matcher m = mobile_pattern.matcher(src); return m.matches(); } @Override public void initialize(IsMobile constraintAnnotation) { required = constraintAnnotation.isRequired(); } @Override public boolean isValid(String phone, ConstraintValidatorContext constraintValidatorContext) { //是否为手机号的实现 if (required) { return isMobile(phone); } else { if (StringUtils.isEmpty(phone)) { return true; } else { return isMobile(phone); } } } } 实现手动校验 步骤一：封装接收校验结果的类 ValidationResult package com.imooc.validator.utils; import org.apache.commons.lang3.StringUtils; import java.util.HashMap; import java.util.Map; public class ValidationResult { private boolean hasErrors = false; private Map errMsgMap = new HashMap<>(); public boolean isHasErrors() { return hasErrors; } public void setHasErrors(boolean hasErrors) { this.hasErrors = hasErrors; } public Map getErrMsgMap() { return errMsgMap; } public void setErrMsgMap(Map errMsgMap) { this.errMsgMap = errMsgMap; } /** * 格式化错误信息 * @return */ public String getErrMsg() { return StringUtils.join(errMsgMap.values().toArray(), \",\"); } } 步骤二：封装完成校验的工具类 利用 javax.validation.Validator 对象完成校验。 ValidatorUtils package com.imooc.validator.utils; import javax.validation.ConstraintViolation; import javax.validation.Validation; import javax.validation.Validator; import javax.validation.ValidatorFactory; import java.util.Set; public class ValidatorUtils { private static final Validator validator; static { ValidatorFactory factory = Validation.buildDefaultValidatorFactory(); validator = factory.getValidator(); } public static ValidationResult validate(Object object) { ValidationResult validationResult = new ValidationResult(); Set> violations = validator.validate(object); if (violations.size() > 0) { validationResult.setHasErrors(true); violations.forEach(constraintViolation -> { String errMsg = constraintViolation.getMessage(); String propertyName = constraintViolation.getPropertyPath().toString(); validationResult.getErrMsgMap().put(propertyName, errMsg); }); } return validationResult; } /** * 校验部分属性 * @param object * @param propertyNames * @return */ public static ValidationResult validPropertys(Object object, String... propertyNames ) { ValidationResult validationResult = new ValidationResult(); for (String propertyName : propertyNames) { Set> violations = validator.validateProperty(object, propertyName); if (violations.size() > 0) { if (!validationResult.isHasErrors()) { validationResult.setHasErrors(true); } violations.forEach(constraintViolation -> { String errMsg = constraintViolation.getMessage(); validationResult.getErrMsgMap().put(propertyName, errMsg); }); } } return validationResult; } } "},"spring/springTransaction.html":{"url":"spring/springTransaction.html","title":"spring transaction","keywords":"","body":"Spring 事务管理 事务特性 原子性 一致性 隔离性 持久性 spring 事务管理接口 PlatformTransactionManager 事务管理器 事务的隔离级别 事务的传播行为 spring 事务管理 "},"spring/springIoc.html":{"url":"spring/springIoc.html","title":"spring ioc","keywords":"","body":"Spring IOC Spring 注解 使用注解需要在 xml 中配置包扫描 Spring 提供如下几个 Annotation 来标注 Spring Bean: @Configuration: 标注配置类 相当于 xml 文件 @Bean标注配置类里方法 方法返回的的对象将由 spring 容器管理，参数对象根据类型从 Spring 容器中获得。 @Component: 标注一个普通的 Spring Bean 类 @Controller: 标注一个控制器组件类 @Service: 标注一个业务逻辑组件类 @Repository: 标注一个 DAO 组件类 注入依赖的对象： @Resource @Resource 不仅可以修饰 setter 方法，也可以直接修饰实例变量 @Autowired 可以修饰实例变量和方法 ，require=false 表明参数对象不是必需的(即 Spring 容器没有参数类型的对象则不会调用被注解的方法)， @Value 获得配置文件中 key 对应的值， @Value(\"${key:默认值}\") 为 bean 的属性注入静态常量 org.springframework.beans.factory.config.FieldRetrievingFactoryBean 用非静态的 Setter 方法可以给 bean 的静态变量注入值 Spring 读取 properties 配置文件 ${key} 获取 key 对应的值 classpath:db.properties classpath:redis.properties org.springframework.core.io.Resource bean 某些属性是 Resource 类型，Spring 能自动将 url 转成 Resource。 org.springframework.core.io.ResourceLoader 能够将classpath,file,http路径的文件加载成 Resource 对象 获取 ApplicationContext 对象 实现 ApplicationContextAware 接口 @Component public class ApplicationContextHolder implements ApplicationContextAware { private static ApplicationContext ctx; public static ApplicationContext getContext(){ return ctx; } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(\"ApplicationContextHolder execute...setApplicationContext()\"); ctx = applicationContext; } } 通过 classpath 下的 xml 获取 ApplicationContext ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"/spring.xml\"); 定时任务 开启注解驱动，@org.springframework.scheduling.annotation.Scheduled注解任务方法。 Junit 单元测试 引入spring-test依赖 实例代码： @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(\"classpath:spring/applicationContext.xml\") public class EmployeeRepositoryTest { // 测试自定义的方法 private Logger logger = LoggerFactory.getLogger(EmployeeRepositoryTest.class); @Autowired private EmployeeRepository employeeRepository; @Test public void findByName() throws Exception { List employees = employeeRepository.findByName(\"Curry\"); for (Employee employee : employees) { logger.info(\"employee={}\", employee); } } } "},"spring/springAop.html":{"url":"spring/springAop.html","title":"spring aop","keywords":"","body":"SpringAOP AOP 相关概念 Advice 类型 Advisor Pointcut AOP 代理选择 AOP 注意事项 AOP XML 方式 示例代码： 业务类 package aop; public class Mooc { public void say() { System.out.println(\"hello....imooc....\"); } public void exc() throws Exception { System.out.println(\"throw...exception\"); throw new RuntimeException(\"抛出一个异常\"); } public int add(int a, int b){ return a+b; } public int sub(int a, int b){ return a-b; } } 切面类 package aop; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.Signature; import java.util.Arrays; import java.util.List; //切面类 public class MoocAspect { public void before(JoinPoint joinPoint) { Signature signature = joinPoint.getSignature(); String methodName = signature.getDeclaringTypeName()+\"_\"+ signature.getName(); List args = Arrays.asList(joinPoint.getArgs()); System.out.println(\"MoocAspect....before method:\"+methodName+ \" args: \" + args); } public void afterThrowing(JoinPoint joinPoint, Exception e) { Signature signature = joinPoint.getSignature(); String methodName = signature.getDeclaringTypeName()+\"_\"+ signature.getName(); System.out.println(\"MoocAspect....after-throwing...method:\"+methodName+\" exception: \"+e.getMessage()); } public void after(JoinPoint joinPoint) { Signature signature = joinPoint.getSignature(); String methodName = signature.getDeclaringTypeName()+\"_\"+ signature.getName(); System.out.println(\"MoocAspect....after the method:\"+methodName); } public void afterReturning(JoinPoint joinPoint, Object returnValue) { Signature signature = joinPoint.getSignature(); String methodName = signature.getDeclaringTypeName()+\"_\"+ signature.getName(); System.out.println(\"MoocAspect....afterReturning method:\"+methodName+\" returnValue:\"+returnValue); } public Object around(ProceedingJoinPoint pjp, int a, int b) { Object object = null; System.out.println(\"Aspect....around: \" + \"a: \" + a + \" b: \" + b); try { System.out.println(\"Aspect....around1\"); object = pjp.proceed(); System.out.println(\"Aspect....around2\"); } catch (Throwable e) { e.printStackTrace(); } return object; } } xml AOP aspectj 方式 maven 依赖： org.aspectj aspectjrt 1.8.5 org.aspectj aspectjweaver 1.8.5 xml 配置： 示例代码： 切面类 package aspect; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; import java.util.Arrays; import java.util.List; @Component @Aspect //排除自己 public class LogAspect { //Aspectj切入点表达式 根据方法签名匹配 // 还有别的方式 扫描包，指定对象，含有注解(自定义注解)的类 @Pointcut(\"execution(* aspect.Calculator.*(..))\") public void log() { } @Before(\"log()\") public void before(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); List args = Arrays.asList(joinPoint.getArgs()); System.out.println(\"Before The method \" + methodName + \" begins \" + args); } //后置通知 @After(\"log()\") public void afterMethod(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); List args = Arrays.asList(joinPoint.getArgs()); System.out.println(\"After The method \" + methodName + \" ends \" + args); } @AfterReturning(pointcut = \"log()\", returning = \"returnValue\") public void afterReturning(Object returnValue) { System.out.println(\"afterReturning: \" + returnValue); } @AfterThrowing(pointcut = \"log()\", throwing = \"e\") public void afterThrowing(RuntimeException e) { System.out.println(\"AfterThrowing: \" + e.getMessage()); } @Around(\"execution(* aspect.Calculator.add(int,int)) && args(a,b)\") public Object around(ProceedingJoinPoint proceedingJoinPoint, int a, int b) { Object object = null; System.out.println(\"Aspect....around: \" + \"a: \" + a + \" b: \" + b); try { //执行被代理的方法 System.out.println(\"around1\"); object = proceedingJoinPoint.proceed(); System.out.println(\"around2\"); } catch (Throwable e) { e.printStackTrace(); } return object; } } "},"spring/springsession.html":{"url":"spring/springsession.html","title":"spring session","keywords":"","body":"SpringSession maven 依赖： org.springframework.session spring-session-data-redis 1.2.0.RELEASE 在 web.xml 中 注册org.springframework.session.web.http.SessionRepositoryFilter, sessionRepositoryFilter 实例对象存在于 Spring 容器中。 springSessionRepositoryFilter org.springframework.web.filteDelegatingFilterProxy springSessionRepositoryFilter /* org.springframework.session.config.annotation.web.http.SpringHttpSessionConfiguration 是一个配置类，其中springSessionRepositoryFilter()方法返回SessionRepositoryFilter类的实例对象 @Configuration public class SpringHttpSessionConfiguration { @Bean public SessionRepositoryFilterspringSessionRepositoryFilter( SessionRepository sessionRepository) { SessionRepositoryFilter sessionRepositoryFilter = new SessionRepositoryFilter( sessionRepository); sessionRepositoryFilter.setServletContext(this.servletContext); if (this.httpSessionStrategy instanceof MultiHttpSessionStrategy) { sessionRepositoryFilter.setHttpSessionStrategy( (MultiHttpSessionStrategy) this.httpSessionStrategy); } else { sessionRepositoryFilter.setHttpSessionStrategy(this.httpSessionStrategy); } return sessionRepositoryFilter; } } org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration 配置 "},"spring/springdata.html":{"url":"spring/springdata.html","title":"spring data","keywords":"","body":"Spring Data Spring Data 作为 SpringSource 的其中一个子项目，旨在统一和简化对各类型持久化存储和访问，而不拘泥于是关系型数据库还是 NoSQL 数据存储，使得对数据库的访问变得方便快捷，并支持 MapReduce 框架及云计算服务；对于拥有海量数据的项目，可以用 Spring Data 来简化项目的开发，就如 Spring Framework 对 JDBC、ORM 的支持一样，Spring Data 会让数据的访问变得更加方便，极大提高开发效率 Spring Data JPA maven依赖: org.springframework.data spring-data-jpa 1.8.0.RELEASE org.hibernate hibernate-entitymanager 4.3.6.Final spring配置： true 500 org.hibernate.cfg.ImprovedNamingStrategy org.hibernate.dialect.MySQL5InnoDBDialect true true update 注解实体类： @javax.persistence.Entity 关于org.springframework.data.repository.Repository接口 Repository 没有包含方法声明，是一个标记接口。 自定义接口继承 Repository 接口，将由 spring 管理;可以使用@org.springframework.data.repository.RepositoryDefinition注解代替继承方式。 接口继承关系：JpaRepository>>PagingAndSortingRepository(分页)>>CrudRepository(实现 CURD)>>Repository；自定义接口继承 JpaRepository 就可以实现 CURD 和分页功能。 org.springframework.data.jpa.repository.JpaSpecificationExecutor接口 继承这个接口后可以添加查询条件 自定义的 Repository 接口 方法声明需要按照一定的规则，缺点是难以实现复杂的查询。 使用@org.springframework.data.jpa.repository.Query注解方法不需要遵循命名规则，支持原生 sql 查询。 @org.springframework.data.jpa.repository.Modifying配合@Query完成更新操作；需要事务管理。 示例代码: public interface EmployeeRepository extends JpaSpecificationExecutor,JpaRepository { // 符合一定的规则 public List findByName(String name); //不需要符合命名规则 //HQL @Query(\"select o from Employee o where id=(select max(id) from Employee t1)\") public Employee getEmployeeByMaxId(); // 占位符 =?1 =?2 @Query(\"select o from Employee o where o.name like %:name% \") public List queryLike(@Param(\"name\")String name); //原生sql查询 @Query(nativeQuery = true, value = \"select count(1) from employee\") public long getCount(); //需要事务管理 @Modifying @Query(\" update Employee o set o.age=:age where o.id=:id \") public int updateAge(@Param(\"id\")Integer id,@Param(\"age\")Integer age); } 分页查询: public Page getPage(int pageNum, int pageSize){ Order order = new Order(Direction.ASC, \"id\"); Sort sort = new Sort(order); //page zero-based page index. // ctrl+h 查看子类 实例化 Pageable pageable = new PageRequest(pageNum-1, pageSize,sort); return employeeRepository.findAll(pageable); } public Page findPage(int pageNum, int pageSize,final String name){ // 添加查询条件 Specification spec = new Specification() { @Override public Predicate toPredicate(Root root, CriteriaQuery query, CriteriaBuilder cb) { Path path = root.get(\"name\"); return cb.like(path, \"%\"+name+\"%\"); } }; Order order = new Order(Direction.ASC, \"id\"); Sort sort = new Sort(order); Pageable pageable = new PageRequest(pageNum-1, pageSize, sort); return employeeRepository.findAll(spec, pageable); } Spring Data Redis maven依赖: org.springframework.data spring-data-redis 1.8.10.RELEASE redis.clients jedis 2.9.0 spring配置： 封装redisTemplate: @Component public class RedisOperator { @Autowired private RedisTemplate redisTemplate; // Key（键），简单的key-value操作 /** * 实现命令：TTL key，以秒为单位，返回给定 key的剩余生存时间(TTL, time to live)。 * * @param key * @return */ public long ttl(String key) { return redisTemplate.getExpire(key); } /** * 实现命令：expire 设置过期时间，单位秒 * * @param key * @return */ public void expire(String key, long timeout) { redisTemplate.expire(key, timeout, TimeUnit.SECONDS); } /** * 实现命令：INCR key，增加key一次 * * @param key * @return */ public long incr(String key, long delta) { return redisTemplate.opsForValue().increment(key, delta); } /** * 实现命令：KEYS pattern，查找所有符合给定模式 pattern的 key */ public Set keys(String pattern) { return redisTemplate.keys(pattern); } /** * 实现命令：DEL key，删除一个key * * @param key */ public void del(String key) { redisTemplate.delete(key); } // String（字符串） /** * 实现命令：SET key value，设置一个key-value（将字符串值 value关联到 key） * * @param key * @param value */ public void set(String key, String value) { redisTemplate.opsForValue().set(key, value); } /** * 实现命令：SET key value EX seconds，设置key-value和超时时间（秒） * * @param key * @param value * @param timeout （以秒为单位） */ public void set(String key, String value, long timeout) { redisTemplate.opsForValue().set(key, value, timeout, TimeUnit.SECONDS); } /** * 实现命令：GET key，返回 key所关联的字符串值。 * * @param key * @return value */ public String get(String key) { return (String) redisTemplate.opsForValue().get(key); } // Hash（哈希表） /** * 实现命令：HSET key field value，将哈希表 key中的域 field的值设为 value * * @param key * @param field * @param value */ public void hset(String key, String field, Object value) { redisTemplate.opsForHash().put(key, field, value); } /** * 实现命令：HGET key field，返回哈希表 key中给定域 field的值 * * @param key * @param field * @return */ public String hget(String key, String field) { return (String) redisTemplate.opsForHash().get(key, field); } /** * 实现命令：HDEL key field [field ...]，删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。 * * @param key * @param fields */ public void hdel(String key, Object... fields) { redisTemplate.opsForHash().delete(key, fields); } /** * 实现命令：HGETALL key，返回哈希表 key中，所有的域和值。 * * @param key * @return */ public Map hgetall(String key) { return redisTemplate.opsForHash().entries(key); } // List（列表） /** * 实现命令：LPUSH key value，将一个值 value插入到列表 key的表头 * * @param key * @param value * @return 执行 LPUSH命令后，列表的长度。 */ public long lpush(String key, String value) { return redisTemplate.opsForList().leftPush(key, value); } /** * 实现命令：LPOP key，移除并返回列表 key的头元素。 * * @param key * @return 列表key的头元素。 */ public String lpop(String key) { return (String) redisTemplate.opsForList().leftPop(key); } /** * 实现命令：RPUSH key value，将一个值 value插入到列表 key的表尾(最右边)。 * * @param key * @param value * @return 执行 LPUSH命令后，列表的长度。 */ public long rpush(String key, String value) { return redisTemplate.opsForList().rightPush(key, value); } } "},"spring/springhibernate.html":{"url":"spring/springhibernate.html","title":"整合 hibernate","keywords":"","body":"Spring 整合 Hiernate maven 依赖： mysql mysql-connector-java 5.1.20 runtime org.hibernate hibernate-core 4.3.6.Final org.hibernate hibernate-ehcache 4.3.6.Final org.springframework spring-orm 4.1.3.RELEASE org.springframework spring-context-support4.1.3.RELEASE org.springframework spring-tx 4.1.3.RELEASE Spring 配置： org.hibernate.dialect.MySQLDialect true true update create --> true true org.hibernate.cache.ehcache.EhCacheRegionFactory --> 用注解标注实体类 import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.Id; import org.hibernate.annotations.Cache; import org.hibernate.annotations.CacheConcurrencyStrategy; // hibernate注解可以写在字段属性或者get方法上 @Cache(usage=CacheConcurrencyStrategy.READ_WRITE,region=\"ehcacheName\",include=\"all\") @Entity(name=\"seller\") public class Seller { @Id @GeneratedValue private Integer id; @Column(length=30) private String name; @Column(length=30) private String tel; @Column(length=50) private String address; @Column(length=30) private String website; @Column private Integer star; @Column(length=30) private String business; public Seller() { } public Seller(String name, String tel, String address, String website, Integer star, String business) { this.name = name; this.tel = tel; this.address = address; this.website = website; this.star = star; this.business = business; } public Integer getId() { return this.id; } public void setId(Integer id) { this.id = id; } public String getName() { return this.name; } public void setName(String name) { this.name = name; } public String getTel() { return this.tel; } public void setTel(String tel) { this.tel = tel; } public String getAddress() { return this.address; } public void setAddress(String address) { this.address = address; } public String getWebsite() { return this.website; } public void setWebsite(String website) { this.website = website; } public Integer getStar() { return this.star; } public void setStar(Integer star) { this.star = star; } public String getBusiness() { return this.business; } public void setBusiness(String business) { this.business = business; } @Override public String toString() { return \"Seller [id=\" + id + \", name=\" + name + \", tel=\" + tel + \", address=\" + address + \", website=\" + website + \", star=\" + star + \", business=\" + business + \"]\"; } } "},"frontend/":{"url":"frontend/","title":"前端","keywords":"","body":"前端知识总结 web 前端开发基础技术需要掌握：HTML、CSS、JavaScript 语言 HTML 是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS 样式是表现。就像网页的外衣。比如，标题字体、颜色变化，或为标题加入背景图片、边框等。所有这些用来改变内容外观的东西称之为表现。 JavaScript 是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单。或鼠标滑过表格的背景颜色改变。还有焦点新闻（新闻图片）的轮换。可以这么理解，有动画的，有交互的一般都是用 JavaScript 来实现的。 "},"frontend/html/html.html":{"url":"frontend/html/html.html","title":"html","keywords":"","body":"html html 文件 结构 称为根标签，所有的网页标签都在中。 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有、、 、、 等标签。 在和标签之间的内容是网页的主要内容，如、、、等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。 ... ... 元素标签 标签: 段落文本 标签: 标题标签一共有 6 个，h1、h2、h3、h4、h5、h6分别为一级标题、二级标题、三级标题、四级标题、五级标题、六级标题。并且依据重要性递减。标题文本 标签: 用粗体表示.需要强调的文本 : 列表 信息 信息 ...... ol: ol 有序列表 信息 信息 ...... 标签: 一些独立的逻辑部分划分出来，放在一个标签中，这个标签的作用就相当于一个容器 table标签: table、tbody、tr、th、td …：整个表格以标记开始、标记结束。 …：如果不加 , table 表格加载完后才显示。加上这些表格结构， tbody 包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用 tbody 分段，可以一部分一部分地显示。（通俗理解 table 可以按结构一块块的显示，不在等整个表格加载完后显示。） …：表格的一行，所以有几对 tr 表格就有几行。 …：表格的一个单元格，一行中包含几对...，说明一行中就有几列。 …：表格的头部的一个单元格，表格表头。 标签: 使用标签可实现超链接，它在网页制作中可以说是无处不在，只要有链接的地方，就会有这个标签。 链接显示的文本 click here! 标签: 在网页的制作中为使网页炫丽美观，肯定是缺少不了图片，可以使用标签来插入图片。 form: 网站怎样与用户进行交互？答案是使用 HTML 表单(form)。表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。 : label 标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该 label 标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该 label 标签相关连的表单控件上）。 input: 当用户要在表单中键入字母、数字等内容时，就会用到文本输入框。文本框也可以转化为密码输入框。 type：当 type=\"text\"时，输入框为文本输入框;当 type=\"password\"时, 输入框为密码输入框;当 type=\"radio\" 时，控件为单选框;当 type=\"checkbox\" 时，控件为复选框;type=\"submit\",控件为提交按钮;type=\"reset\" 控件为重置按钮。 name：为文本框的参数名，以备后台程序使用。同一组的单选按钮，name 取值一定要一致. checked：当设置 checked=\"checked\" 时，该选项被默认选中 姓名： 密码： textarea: 当用户需要在表单中输入大段文字时，需要用到文本输入域。 文本 select: 下拉列表在网页中也常会用到，它可以有效的节省网页空间。既可以单选、又可以多选.在标签中设置multiple=\"multiple\"属性，就可以实现多选功能 显示值 显示值 显示值 显示值 css 样式 CSS 全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义 HTML 内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 CSS 样式基本知识 CSS 样式可以写在哪些地方呢？从 CSS 样式代码插入的形式来看基本可以分为以下 3 种： 内联式、嵌入式和外部式三种。 内联式: 把 css 代码直接写在现有的 HTML 标签中，如下面代码: 这里文字是红色。 嵌入式css样式: 把 css 样式代码写在标签之间。 span{ color:red; } 外部式css样式: 把 css 代码写一个单独的外部文件中，这个 css 样式文件以“.css”为扩展名，在内（不是在标签内）使用标签将 css 样式文件链接到 HTML 文件内 三种方法的优先级:内联式 > 嵌入式 > 外部式 嵌入式>外部式有一个前提：嵌入式 css 样式的位置一定在外部式的后面.其实总结来说，就是--就近原则（离被设置元素越近优先级别越高） CSS 选择器 每一条 css 样式声明（定义）由两部分组成，形式如下： 选择器{ 样式; } 在{}之前的部分就是“选择器”，“选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素. CSS 选择器分类： 标签选择器 标签选择器其实就是 html 代码中的标签。 p{font-size:12px;line-height:1.6em;} 类选择器 使用class=\"类选择器名称\"为标签设置一个类,CSS 语法：.类选器名称{css样式代码;} ID 选择器 为标签设置id=\"ID名称\",CSS 语法：#ID名称{css样式代码;} 子选择器 用大于符号(>)选择指定标签元素的第一代子元素。 .food>li{border:1px solid red;} 包含(后代)选择器 包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。 .first span{color:red;} 通用选择器 用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配 html 中所有标签元素 伪类选择符 给 html 不存在的标签（标签的某种状态）设置样式 a:hover{color:red;} 分组选择符 当你想为 html 中多个标签元素设置同一个样式时，可以使用分组选择符, h1,span{color:red;} CSS 的继承、层叠和特殊性 继承: CSS 的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定 html 标签元素，而且应用于其后代。比如下面代码：如某种颜色应用于 p 标签，这个颜色设置不仅应用 p 标签，还应用于 p 标签中的所有子元素文本，这里子元素为 span 标签。 p{color:red;} 三年级时，我还是一个胆小如鼠的小女孩。 重要性: 我们在做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，怎么办？这时候我们可以使用!important 来解决。 p{color:red!important;} p{color:green;} 三年级时，我还是一个胆小如鼠的小女孩。 CSS 格式化排版 字体: body{font-family:\"宋体\";} 字号: body{font-size:12px;color:#666} 粗体: p span{font-weight:bold;} 下划线: p a{text-decoration:underline;} 删除线: .oldPrice{text-decoration:line-through;} 缩进: p{text-indent:2em;} 行高: p{line-height:2em;} 对齐: div{text-align:center;} CSS 颜色 在网页中的颜色设置是非常重要，有字体颜色（color）、背景颜色（background-color）、边框颜色（border）等，设置颜色的方法也有很多种： 英文命令颜色 p{color:red;} RGB 颜色 由 R(red)、G(green)、B(blue) 三种颜色的比例来配色。 p{color:rgb(133,45,200);} 十六进制颜色 这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。 p{color:#00ffff;} CSS 长度值 长度单位总结一下，目前比较常用到 px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位 像素 像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS 规范中假设“90 像素=1 英寸”）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。 em 就是本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。 百分比 p{font-size:12px;line-height:130%} 元素分类 html 中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。常用的块状元素有：、、...、、、、、、 、。常用的内联元素有：、、、、、、、、、、。常用的内联块状元素有：、。 块级元素特点： 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的 100%（和父元素的宽度一致），除非设定一个宽度。 将内联元素转换为块状元素:{display:block;} 内联元素特点： 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 将元素设置为内联元素:{display:inline;} 内联块状元素: 同时具备内联元素、块状元素的特点 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 将元素设置为内联块状元素:{display:inline-block;} CSS 盒子模型: 盒模型宽度和高度和我们平常所说的物体的宽度和高度理解是不一样的，css 内定义的宽（width）和高（height），指的是填充以里的内容范围。 元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 盒模型边界： 元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。{margin:20px 10px 15px 30px;} padding 和 margin 的区别，padding 在边框里，margin 在边框外。 布局模型 三种布局模型： 流动模型（Flow） 浮动模型 (Float) 层模型（Layer） 流动模型: 流动（Flow）是默认的网页布局模式。 块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为 100%。 内联元素都会在所处的包含元素内从左到右水平分布显示。 浮动模型: 块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示设置元素浮动。 任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动，如 div、p、table、img 等元素都可以被定义为浮动。代码：{ float:;} 层模型: 绝对定位(position: absolute) 破坏性(脱离文档流，父容器塌陷) 跟随性(没有设置 left、right、top、bottom 属性,浮在原来位置) 包裹性(容器定位后，如果没有设宽度，那么它将会根据内部内容来显示宽度) 使用 left、right、top、bottom 属性相对于其最接近的一个具有定位属性的父包含块(position:relative)进行绝对定位。 absolute:去浮动,位置跟随. 无依赖绝对定位:不依赖 relative; position:absolute;+margin 定位。 相对定位(position: relative) 如果想为元素设置层模型中的相对定位，需要设置 position:relative（表示相对定位），它通过 left、right、top、bottom 属性确定元素在正常文档流中的偏移位置。 固定定位(position: fixed) 固定定位与 absolute 定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动 而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置。 z-index： 仅能在定位元素上奏效,表示层级关系。 auto：默认。堆叠顺序与父元素相等。0 元素可拥有负的 z-index 属性值,这时会被普通流覆盖。 "},"frontend/javascript/Introduction.html":{"url":"frontend/javascript/Introduction.html","title":"javascript 入门篇","keywords":"","body":"JavaScript 入门篇 HTML 如何插入 JS 使用标签在 HTML 网页中插入 JavaScript 代码 引用 JS 外部文件 JS 在页面中的位置: 放在部分: 最常用的方式是在页面中 head 部分放置元素，浏览器解析 head 部分就会执行这个代码，然后才解析页面的其余部分。 放在部分: JavaScript 代码在网页读取到该语句的时候就会执行。 javascript 作为一种脚本语言可以放在 html 页面中任何位置，但是浏览器解释 html 时是按先后顺序的，所以前面的 script 就先被执行。比如进行页面显示初始化的 js 必须放在 head 里面，因为初始化都要求提前进行（如给页面 body 设置 css 等）；而如果是通过事件调用执行的 function 那么对位置没什么要求的。 如何用 JavaScript 去操作 HTML 元素和 CSS 样式 认识 DOM: 文档对象模型 DOM（Document Object Model）定义访问和处理 HTML 文档的标准方法。DOM 将 HTML 文档呈现为带有元素、属性和文本的树结构（节点树）。 将 HTML 代码分解为 DOM 节点层次图: HTML 文档可以说由节点构成的集合，三种常见的 DOM 节点: 元素节点：上图中、、等都是元素节点，即标签。 文本节点:向用户展示的内容，如...中的 JavaScript、DOM、CSS 等文本。 属性节点:元素属性，如标签的链接属性href=\"http://www.imooc.com\" 通过 ID 获取 DOM 元素: 学过 HTML/CSS 样式，都知道，网页由标签将信息组织起来，而标签的 id 属性值是唯一的，就 像是每人有一个身份证号一样，只要通过身份证号就可以找到相对应的人。那么在网页中，我们通 过 id 先找到标签，然后进行操作。 语法: document.getElementById(“id”) DOM 的 innerHTML 属性: innerHTML 属性用于获取或替换 HTML 元素的内容。 语法: object.innerHTML 改变 HTML 样式: HTML DOM 允许 JavaScript 改变 HTML 元素的样式。如何改变 HTML 元素的样式呢？ 语法: object.style.property=new style; 显示和隐藏(display 属性): 网页中经常会看到显示和隐藏的效果，可通过 display 属性来设置。none:隐藏;block：显示为块级元素即显示。 语法： object.style.display = value 控制 DOM 的类名(className 属性): className 属性设置或返回元素的 class 属性。为网页内的某个元素指定一个 css 样式来更改该元素的外观 语法： object.className = classname Javascript 事件绑定 什么是事件: JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可 以产生某些可以触发 JavaScript 函数或程序的事件。比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览 器做出处理，返回给用户一个结果。 主要事件表: 事件流: 事件流描述的是从页面中接受事件的顺序。 事件冒泡 事件冒泡，即事件最开始由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向 上转 播至最不具体的节点(文档)。 事件捕获 事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。 事件处理程序: HTML 事件处理程序(直接写在 html 上) DOM0 级事件处理程序(通过 js 绑定到 dom 属性) DOM2 级事件处理程序 DOM2 级事件定义了两个方法：用于处理指定和删除事件处理程序的操作：addEventListener ()和 removeEventListener()。它们都接收三个参数：要处理的事件名、作为事件处理程序 的函数和一个布尔值。 IE 事件处理程序 attachEvent()添加事件 detachEvent()删除事件 这两个方法接收相同的两个参数：事件处理程序名称与事件处理函数 事件对象: 事件对象 event： type:获取事件类型 target：事件目标 stopPropagation() 阻止事件冒泡 preventDefault() 阻止事件的默认行为(如 a 标签跳转) 浏览器(window)对象 window 对象是 BOM 的核心，window 对象指当前的浏览器窗口。 window 对象方法: JavaScript 计时器: 在 JavaScript 中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。 计时器类型： 一次性计时器：仅在指定的延迟时间之后触发一次。 间隔性触发计时器：每隔一定的时间间隔就触发一次。 计时器方法： History 对象: history 对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功 能。 语法： window.history.[属性|方法] History 对象方法: location 对象: location 用于获取或设置窗体的 URL，并且可以用于解析 URL。 location 对象属性： location 对象方法: screen 对象: screen 对象用于获取用户的屏幕信息。 Navigator 对象: Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 跳出 iFrame var topWindow = window; while(topWindow.parent != topWindow) { topWindow = topWindow.parent; } "},"frontend/javascript/base.html":{"url":"frontend/javascript/base.html","title":"javascript 基础知识","keywords":"","body":"JavaScript 基础知识 JavaScript 语法基础 严格模式：提高错误检查，增强安全性 'use strict'; 变量定义: let 定义普通变量（推荐）。 const 定义常量，后面只能读不能写。 var 定义普通变量，不建议使用。 由于 JavaScript 是弱类型语言，因此你不需要声明变量的数据类型。 let x = 20; 数据类型 基础类型包括： Undefined Null Boolean Number String 对象类型 Object： Date Array Function .... undefined 声明一个变量没有赋值，直接访问当前变量可以得到 undefined。 let x; console.log(x); // -> undefined 访问一个对象上不存在的 key 也会取到 undefined。 let a = {}; console.log(a.b); // -> undefined null 表示空值。它不同于 undefined，它是有值的只不过是一个空值，而 undefined 是未定义的临时兜底的缺省值。 Array 数组类型，栈结构，有序数组。每个 item 可以是任意类型的值. // 字符串数组 ['string', 'aaa'] // 对象和字符串混合数组 [{ aa: 'aaa', bb: 'bbb', }, 'string'] // 函数数组 [() => { return '这是一个函数' }, () => { return '这是一个函数' }] // Array简易循环举例： let list = []; list.push('aa'); list.push('bb'); for(let i=0; i i); //map 数组映射返回arr2,arr不变 console.log(`arr2.toString(): ${arr2.toString()}`); console.log(`arr2.join('_'): ${arr2.join('_')}`); //join 数组转成String ,arr2不变 arr2.forEach((v, i) => { //数字变量，返回void console.log(`index: ${i} value: ${v}`); }); let arr3 = arr2.filter(v => { //filter 数组过滤，返回arr3,arr2不变 if (v % 2 === 0) { return v; } }); console.log(`arr3: ${arr3.toString()}`); console.log(`arr3.indexOf(4): ${arr3.indexOf(4)}`); let result = arr3.every(v => v v object对象类型 对象类型，无序，需要指定 key 等信息关联值，类似 Java 的 HashMap，比如： // 字面量创建对象 let obj = { name: 'string 字符串', home: { province: '山东' } }; obj.age = 18; console.log(obj.home.province); let key = 'age'; console.log(obj[key], obj['age']); delete obj.name; // 通过in遍历对象属性 for (const key in obj) { if (obj.hasOwnProperty(key)) {// 只要自身属性 const element = obj[key]; console.log(element); } } // 通过构造器创建对象 function foo(){ } foo.prototype= { say:function(){ console.log(\"hello world\"); }, z:3 } // obj2对象的原型会指向构造器foo的prototype属性 let obj2 = new foo(); obj2.x=1; obj2.y=2; obj2.x;//1 obj2.y;//2 obj2.z;//3 'z' in obj2;//true obj2.hasOwnProperty('z');//false obj2.say(); function 函数类型，用来创建一个函数，通常会返回一个数据。 function fun(a, b) { return a + b; } fun(1, 2); // -> 3; 立即执行函数表达式： (function(){ })(); !function(){ }(); 函数是一个可执行的小程序，根据参数处理一些逻辑并返回一段新的数据，在 JavaScript 中用非常多，为此 ES6（新版 JavaScript 语言规范）新增了箭头函数语法，用来简化函数书写： let add = function(a, b) { return a + b; }; 等同于 let add = (a, b) => { return a + b; }; 类型转换 类型转换可以通过调用类型的类进行转换，比如将变量 a 转换成 Number 类型，可以使用： let a = '10'; a = Number(a); 转换 number 类型 JavaScript: let a = '12.33'; console.log(parseInt(a)); // -> 12 number console.log(parseFloat(a)); // -> 12.33 number 转换 string 类型 同 Java 每个类型的值都含有 toString() 方法。 let a = 12.33; console.log(a.toString()); // -> '12.33' 将 Object 转成 JSON 字符串 let obj = { a: 'aa', b: 'bb' }; console.log(JSON.stringify(obj)); // -> '{\"a\":\"aa\",\"b\":\"bb\"}' let objStr = '{\"a\":\"aa\",\"b\":\"bb\"}'; 将 JSON转成 Object console.log(JSON.parse(objStr)); // -> {a:\"aa\", b:\"bb\"} 转换 boolean 类型 JavaScript 中的 boolean 的值比较多，空字符串、数字 0、null、undefined 均为布尔值的 false。此外 ! 表示取当前布尔值的反值，可以通过 !! 巧妙的将值转换成布尔值类型的数据。 console.log(!!'a'); // -> true console.log(!!''); // -> false 空字符串 console.log(!!0); // -> false 数字 0 console.log(!!10); // -> true console.log(!!null); // -> false console.log(!!undefined); // -> false console.log(!![].length); // -> false 类型检测： typeof 适合基本类型和function类型检测 instanceof 检查对象的类型是否是自定义的类型 function foo() {} var obj = new foo(); console.log(obj instanceof foo); == 和 === 的区别: JS 是弱类型语言，=== 表示全等判断，会把类型也进行比较： 2 == '2' // -> true 2 === '2' // -> false + 运算符会改变数据类型 运算符会导致数据类型的改变，这是因为运算符同时表示多种含义导致。+ 运算符既可以链接字符串，也可以计算数字，使用时需要注意： 2 + 2 // -> 4 number 2 + '2' // -> '22' string JavaScript 正则表达式 RegExp javascript 通过内置对象 RegExp 支持正则表达式。 实例化方法 构造函数 var reg = new RegExp('\\\\bis\\\\b','g'); 字面量 var reg = /\\bis\\b/g; []构造一个类 /[a-zA-Z]/ \"a1b2c3d4f5g6\".replace(/[a-g]/g,\"X\"); \"a1b2c3d4f5g6\".replace(/[^a-g]/g,\"X\")； 边界字符 ^ 开始 $ 结束 \"@1a@2a@3a\".replace(/^@./g,\"X\"); \"@1a@2a@3a@\".replace(/.@$/g,\"X\"); 量词 {n} 匹配 n 个相同的字符 /\\d{3}/.test(123); \"12345678\".replace(/\\d{3,6}/,\"X\"); \"12345678\".replace(/\\d{3,6}?/,\"X\"); () 分组 \"@1a@2a@3a@\".replace(/(@\\d.){2}/g,\"X\"); \"2015-02-14\".replace(/^(\\d{4})-(\\d{2})-(\\d{2})$/g,\"$2/$3/$1\"); '15977391234'.replace(/(\\d{3})(\\d{4})(\\d{4})/,'$1****$3'); Promise 语法 Promise 示例 // 执行$.ajax请求 var request=function (param) { return new Promise(function (resolve, reject) { $.ajax({ type: param.method || 'get', timeout: 10000, url: param.url || '', data: param.data || '', dataType: param.dataType || 'json', success: function (response) { if ('success' === response.status) { typeof resolve === 'function' && resolve(response.data); } else { typeof reject === 'function' && reject(response.data); } }, error: function (error) { alert(error.statusText) } }); }); } // 调用 request({param}).then(function(data){ // 成功处理 },function(data){ // 失败处理 }); javascript 模块化 CommonJS 使用 module.exports=xxx导出模块，使用 var xxx=require('模块文件路径')引入模块. 可以导出常量，函数，对象。 代码： // a.js function say(params) { return `hello ${params}`; } module.exports = say; //b.js const say = require('./a'); console.log(say('tom')); ES6 使用 (export|export default)导出模块，使用 import from '文件路径'引入模块. export 可以在单个文件导出多个模块，利用 import {xxxx,xxxx } from引入。 export default 导出一个模块，利用 import xxxx from引入。 代码： // a.js function say(params) { return `hello ${params}`; } export default say; //b.js import say from './a'; console.log(say('tom')); "},"frontend/jquery/jquery.html":{"url":"frontend/jquery/jquery.html","title":"jquery ","keywords":"","body":"jQuery 引入 window.$===window.jQuery 等待 DOM 加载完成 window.onload=function(){} $(function(){}); $(document).ready(function(){}); jQuery 拓展实例方法 例子: $.fn.extend (function($) { var hello = function(str) { console.log('hello ' + str); }; $.fn.extend({ hello: function() { // 调用hello函数的是一个jQuery对象(this)， // 类选择器调用则通过 this.each(function(){}) 遍历 new hello(this.text()); return this; } }); })(jQuery); //设置匿名函数的私有作用域，防止污染 // 调用 $(function() { $('#test').hello(); }); functions add() //把p元素加到li合集中 $('li').add('p').css('background', 'red') append() //.append(), 选择表达式在函数的前面， //参数是将要插入的内容。 $(\".content\").append('通过append方法添加的元素') //.appendTo()刚好相反，内容在方法前面， //无论是一个选择器表达式 或创建作为标记上的标记 //它都将被插入到目标容器的末尾。 $('通过appendTo方法添加的元素').appendTo($(\".content\")) attr() $(\"#div1\").attr(\"title\") children() // 返回匹配元素集合中每个元素的所有子元素 $(\".div\").children().css('border', '1px solid red') //找到所有class=div的元素 //找到其对应的子元素ul，然后筛选出最后一个，给边宽加上颜色 $('.div').children(':last').css('border', '3px solid blue') class操作 $(function () { $(\"#p1\").click(function () { if ($(this).hasClass(\"p1\")) { $(this).removeClass(\"p1\"); } else { $(this).addClass(\"p1\"); }); $(\"#p2\").click(function(){ // 如果存在（不存在）就删除（添加）一个类 $(this).toggleClass('p1'); }); }); css() js 写法 domObj.style.keyname=value $(\"#p1\").click(function () { $(this).css({ color: 'red' }) }); data() data-pid=\"10001\" $(function () { $(\"#p1\").click(function(){ alert($(this).data(\"pid\")); }); }); each() 包含静态方法和实例方法 $(function () { $(\".d\").each(function (index, elem) { //elem --dom obj //each回调方法中的this指向当前迭代的dom元素 console.log(elem.getAttribute('title')); }); var list = [1, 2, 3, 4]; $.each(list, function(index, item) { console.log('index: ' + index + ' item: ' + item); }); }); empty() //通过empty移除了当前div元素下的所有p元素 //但是本身id=test的div元素没有被删除 $(\"#test\").empty() extend() 对象合并 $(function () { var obj = { name: 'james', age: 32 }; $.extend(obj, { team: 'CLE', age: 33 }); console.log(obj); }); find() var $spans = $('span'); $(\"p\").find($spans).css('color', 'red'); get() var $divs = $('div'); // to dom var dom1 = $divs.get(0); dom1.style.color = 'red'; // jquery var dom3 = $divs.eq(2).css({ color: 'blue' }); if(dom3 instanceof jQuery){ alert(\"dom3 is jQuery obj\"); } hover() $(\"#p1\").hover(function(){ $(this).addClass('p1'); },function(){ $(this).removeClass('p1'); }); html() js 写法 obj.innerHTML=value //html文档结构 $('p:first').text($(\".first-div\").html()); //.text()是文本内容的合集 $('p:last').text($(\".first-div\").text()) index() 1 2 3 4 5 $(function () { $(\".p1\").click(function(e){ alert($(this).index()); }); }); is() 参数是选择器字符串， 返回 boolean, $('#p1').is('.p1') isEmptyObject() $(function () { var obj = { \"姓名\": \"土豪一族\" }; var strTmp = \"您定义了一个：\"; if ($.isEmptyObject(null)) { //检测是否为空 strTmp += \"空对象\"; } else { strTmp += \"非空对象\"; } $(\".content\").html(strTmp); }); keyup() $(function () { // 数字的keyCode(ascii)=ox30+数值 $('#val1').keyup(function (e) { console.log(e.type); console.log(e.keyCode); }) }); on() 事件绑定 1 2 3 4 5 $(function () { $(\".d1\").on('click','.p1',function(e){ alert(e.target.textContent); }); }); param() $(function() { var obj = { name: 'james', age: 32 }; // name=james&age=32 console.log($.param(obj)); }); parent() //找到所有class=item-a的父元素 //然后给每个ul,然后筛选出最后一个，加上蓝色的边 $('.item-a').parent(':last').css('border', '1px solid blue') parents() //找到当前元素的所有祖辈元素,筛选出class=\"first-div\"的元素 //并且附上一个边 $('.item-b').parents('.first-div').css('border', '2px solid blue') remove() //删除整个 class=test1的div节点 $(\".test1\").remove() serialize() //username=sdfsd&password=sdfsdf&Checkbox1=true console.log($('form').serialize()); siblings() 操作兄弟节点 标题1 标题2 标题3 标题4 标题5 $(function () { $(\".nav-item\").click(function () { // this是 dom对象 console.log(this); $(this).addClass(\"active\").siblings().removeClass(\"active\"); }); }); trim() $(function () { var str=\"sdsfsdf \"; console.log($.trim(str)); }); val() 表单的 value $(\"#single\").val() jQuery Validation Plugin jQuery Validation Plugin 是表单验证插件。 该插件自带包含必填、数字、URL 在内容的验证规则，即时显示异常信息，此外，还允许自定义验证规则。 引入： 核心方法： validate 定义了基本的校验规则和一些有用的配置项。 调用方法如下： $(form).validate({options}) 其中 form 参数表示表单元素，options 参数表示调用方法时的配置对象，所有的验证规则和异常信息显示的位置都在该对象中进行设置。 options： debug(default: false)：如果这个参数为 true,那么表单不会提交，只进行检查 rule:验证规则,指元素和验证方法的关联。 { 要验证的字段名:{ 验证方法:xxxxx, 验证方法:xxxxx } ... } messages：提示信息 { 要验证的字段名:{ 验证方法:提示信息, 验证方法:提示信息 } ... } 基本验证方法: 示例代码： $(document).ready(function () { $(\"#demoForm\").validate({ // debug: true 不会提交 debug: false, rules: { // 对应与字段的name属性 username: { required: true, minlength: 2, maxlength: 10, //远程检验 remote: { url: 'remote.json', type: 'POST', data: { loginTime: + new Date() } } }, password: { required: true, minlength: 2, maxlength: 16 }, \"confirm-password\": { equalTo: \"#password\" }, email: { required: true, email: true } }, messages: { username: { required: '请输入用户名', minlength: '用户名不能小于2个字符', maxlength: '用户名不能超过10个字符', remote: '用户名不存在' }, password: { required: '请输入密码', minlength: '密码不能小于2个字符', maxlength: '密码不能超过16个字符' }, \"confirm-password\": { equalTo: \"两次输入密码不一致\" }, email: { required: \"请输入邮箱\", email: '请输入邮箱' } }, highlight: function (element, errorClass, validClass) { $(element).addClass(errorClass).removeClass(validClass); $(element).fadeOut().fadeIn(); }, unhighlight: function (element, errorClass, validClass) { $(element).removeClass(errorClass).addClass(validClass); }, submitHandler: function (form) { console.log($(form).serialize()) } }); $(\"#check\").click(function () { // 校验是否通过 alert($(\"#demoForm\").valid() ? \"填写正确\" : \"填写不正确\"); }); }); "},"frontend/http/http.html":{"url":"frontend/http/http.html","title":"http ","keywords":"","body":"http HTTP(HyperText Transfer Protocol)是一套计算机通过网络进行通信的规则。计算机专家设计出 HTTP，使 HTTP 客户（如 Web 浏览器）能够从 HTTP 服务器(Web 服务器)请求信息和服务，HTTP 目前协议的版本是 1.1.HTTP 是一种无状态的协议，无状态是指 Web 浏览器和 Web 服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后 Web 服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。Web 浏览器向 Web 服务器发送请求，Web 服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。 一个完整的 HTTP 请求过程： 建立 TCP 连接 Web 浏览器向 Web 服务器发送请求命令 Web 浏览器发送请求头信息 Web 服务器应答 Web 服务器发送应答头信息 Web 服务器发数据 Web 服务器关闭 TCP 连接 一个 HTTP 请求(Request)一般由四部分组成： HTTP 请求的方法或动作，比如是 GET、POST、PUT、DELETE 请求 正在请求的 URL，总得知道请求的地址是什么吧 请求头，包含一些客户端环境信息，身份验证信息等 请求体，也就是请求正文，请求正文中可以包含客户提交的查询字符串信息，表单信息等等 请求头和请求体中间有空格（很重要） 一般 HTTP 响应(Response)由 3 部分组成： 一个数字或文字组成的状态码，用来显示请求是成功还是失败 响应头，和请求头一样包含许多有用信息，如服务器类型、日期时间、内容类型和长度等 响应体，即响应正文 响应 Response 状态码: 1xx：信息类，web 瀏覽器請求，正在进一步的处理中； 2xx：成功，表示用户请求被正确接受，理解和处理 200 ok 3xx:重定向，表示请求没有成功，客户必须采取进一步的动作 4xx:客户端错误，表单提交的路径有错误，例如 404 not found，以为这请求中所引用的文档不存在 5xx:服务器错误，表示服务器不能完成对请求的处理 ： 如 500 浏览器的同源策略 概述 浏览器同源策略简单来说，即要求只有同源的网页才能够使用共享的网络资源或行为。所谓的\"同源\"，是指协议相同，域名相同，端口相同。 同源策略的目的是为了保证用户信息安全，防止恶意的网站窃取数据。 随着互联网的发展，受到限制的网络资源或行为主要包括以下三种 Cookie，LocalStorage 和 IndexDB DOM Ajax 请求 Cookie 非同源的网页不能共享 Cookie。 但是如果页面一级域名相同，可以通过对页面设置相同的 document.domain 共享 cookie。 也可以在设置 Cookie 时指定 Cookie 的一级域名，实现二级三级域名页面的访问。 LocalStorage 非同源的网页不能共享 LocalStorage，如果需要共享 LocalStorage，可以使用 Html5 新增的 postMessage 方法进行数据传输。 iframe 非同源网页不能获取对方的 DOM。 如果页面一级域名相同，可以通过对页面设置相同的 document.domain。 片段识别符 片段识别符是 URL #后面的部分，片段识别符改变，页面不会重新刷新。 父子窗口可以通过写入片段识别符，并通过监听 hashchange 事件得到通知。 window.postMessage HTML5 为了解决这个问题，引入了一个全新的 API：跨文档通信 API（Cross-document messaging）。 这个 API 为 window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。父窗口和子窗口都可以通过 message 事件，监听对方的消息。 var popup = window.open('http://bbb.com', 'title'); popup.postMessage('Hello World!', 'http://bbb.com'); AJAX 非同源网站不能调用对方 API 代理服务器 通过代理服务器转发 http 请求 JSONP JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 CORS CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，是跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发 GET 请求，CORS 允许任何类型的请求 CORS CORS 是一个 W3C 标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 简单请求与非简单请求 只要同时满足以下两大条件，就属于简单请求。 请求方法是以下三种方法之一： HEAD GET POST HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、 multipart/form-data、text/plain 不满足简单请求条件的请求，就是非简单请求。 常见的非简单请求： PUT,DELETE 方法的 ajax 请求 发送 JSON 的 ajax 请求 带自定义请求头的 ajax 简单请求 CORS 流程 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定 是否同意这次请求。 如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现， 这个回应的头信息没有包含 Access-Control-Allow-Origin 字段（详见下文），就知道出错 了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。 如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。 另一方面，开发者必须在 AJAX 请求中打开 withCredentials 属性。 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。 Access-Control-Expose-Headers 该字段可选。CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、 Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。上面的例子指定，getResponseHeader ('FooBar')可以返回 FooBar 字段的值。 非简单请求 CORS 流程 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为\"预检\"请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。 \"预检\"请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是 Origin，表示请求来自哪个源。 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 除了 Origin 字段，\"预检\"请求的头信息包括两个特殊字段。 Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT。 Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是 X-Custom-Header。 服务器收到\"预检\"请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 关键的是 Access-Control-Allow-Origin 字段，表示可以请求数据。该字段也可以设为星号， 表示同意任意跨源请求。 如果浏览器否定了\"预检\"请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信 息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被 XMLHttpRequest 对象的 onerror 回调函数捕获。 服务器回应的 Header 字段包括： Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返 回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\"预检\"请求。 Access-Control-Allow-Headers 如果浏览器请求包括 Access-Control-Request-Headers 字段，则 Access-Control-Allow-Headers 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支 持的所有头信息字段，不限于浏览器在\"预检\"中请求的字段。 Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天 （1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条 预检请求。 一旦服务器通过了\"预检\"请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一 个 Origin 头信息字段。服务器的回应，也都会有一个 Access-Control-Allow-Origin 头信息 字段。 "},"frontend/ajax/ajax.html":{"url":"frontend/ajax/ajax.html","title":"ajax ","keywords":"","body":"AJAX AJAX：Asynchronous JavaScript and XML （异步的 JavaScript 和 XML） Ajax 不是某种编程语言，是一种在无需重新加载整个网页的情况下能够更新部分网页的技术。 XMLHttpRequest 通过这个对象可以使后台和服务器之间交换数据，而且数据的交换不用重新加载整个页面。有了 XMLHttpRequest 这个对象才能实现异步请求和局部刷新 创建 XHR 对象: var request; if(window.XMLHttpRequest){ request = new XMLHttpRequest(); }else{ request = new ActiveXObject(\"Microsoft.XMLHTTP\");//IE5、6 } XMLHttpRequest 发送 http 请求例子： var request = new XMLHttpRequest(); request.open(\"GET\", \"server.php?number=\" + document.getElementById(\"keyword\").value); request.send(); request.onreadystatechange = function() { if (request.readyState===4) { if (request.status===200) { document.getElementById(\"searchResult\").innerHTML = request.responseText; } else { alert(\"发生错误：\" + request.status); } } } var request = new XMLHttpRequest(); request.open(\"POST\", \"server.php\"); var data = \"name=\" + document.getElementById(\"staffName\").value + \"&number=\" + document.getElementById(\"staffNumber\").value + \"&sex=\" + document.getElementById(\"staffSex\").value + \"&job=\" + document.getElementById (\"staffJob\").value; request.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); request.send(data); request.onreadystatechange = function() { if (request.readyState===4) { if (request.status===200) { document.getElementById(\"createResult\").innerHTML = request.responseText; } else { alert(\"发生错误：\" + request.status); } } jQuery 实现 ajax: settings对象： contentType (default: 'application/x-www-form-urlencoded; charset=UTF-8'). 发送 json 数据改为application/json;charset=utf-8。 data为 json 字符串。 xhrFields: { withCredentials: true } 跨域请求带上 被调用方法的cookie axios 发送 ajax 请求 axios(基于 promise )是用于浏览器和 node.js 的 http 客户端,要使用 axios 需要通过 npm/Yarn 或一个 CDN 链接安装 axios。 axios 特点: 支持浏览器和 node.js 支持 promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换 JSON 数据 浏览器端支持防止 CSRF(跨站请求伪造) AJAX 跨域 AJAX 跨域的原因就是: 浏览器限制 跨域 XMLHttpRequest 利用 发送一个类型为 script 的请求不受跨域限制。 跨域处理方式： 代理 属于调用方的处理 让相同域名下的后端服务器去访问(或者是通过代理服务器如 nginx 转发 http 请求)， 实现隐藏跨域。 JSONP 只能处理 GET 请求,被调用方服务端后台代码需要做相应的处理。 实现原理 利用发送请求,返回的 js 代码调用定义好的函数 //index.html function fun(response) { console.log(response.name + ':' + response.age); } // http://localhost:8080/fun 返回： fun({\"name\":\"James\", \"age\":32 }) $.ajax({dataType:\"JSONP\",jsonp:\"callback\", success:function(){}}) 请求会带上一个callback参数，后端返回 javascript 代码=>callback 函数({响应数据}); SpringMVC 处理 jsonp: import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.servlet.mvc.method.annotation.AbstractJsonpResponseBodyAdvice; @ControllerAdvice public class JsonpAdvice extends AbstractJsonpResponseBodyAdvice { public JsonpAdvice() { // 请求参数是callback super(\"callback\"); } } XHR2 属于被调用方的处理 被调用方服务端添加一些响应头字段，支持跨域请求。nginx添加一些响应头字段 也能实现同样的功能。 发生跨域时 Request Headers 请求头带上 Origin 字段，值为调用方法的域名。 带 cookie 的跨域Response Headers响应头的Access-Control-Allow-Origin字段要和 Origin一样。 filter 过滤器实现: Spring框架直接在类或者方法添加注解@CrossOrigin支持跨域 import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @Component @WebFilter(urlPatterns=\"/\\*\",filterName=\"crosFilter\") public class CrosFilter implements Filter{ @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest)request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; // 发生跨域时请求头带上 Origin String origin = httpServletRequest.getHeader(\"Origin\"); if(!StringUtils.isEmpty(origin)) { httpServletResponse.addHeader(\"Access-Control-Allow-Origin\", origin); } // 自定请求头 String header = httpServletRequest.getHeader (\"Access-Control-Request-Headers\"); if(!StringUtils.isEmpty(header)) { httpServletResponse.addHeader(\"Access-Control-Allow-Headers\", header); } httpServletResponse.addHeader(\"Access-Control-Allow-Methods\", \"*\"); // 带跨域cookie //Access-Control-Allow-Origin 要全部匹配 httpServletResponse.addHeader(\"Access-Control-Allow-Credentials\", \"true\"); chain.doFilter(httpServletRequest, httpServletResponse); } @Override public void destroy() { } } "},"frontend/websocket/WebSocket.html":{"url":"frontend/websocket/WebSocket.html","title":"websocket ","keywords":"","body":"WebSocket web 端的 Socket,Client 和 Server 建立 TCP 长连接，然后相互发送消息。 浏览器发送 WebSocket 连接 WebSocket第一个案例 Echo Test 发送 var websocket = new WebSocket('wss://echo.websocket.org/'); websocket.onopen = function() { console.log('websocket open'); document.getElementById('recv').innerHTML = 'Connected'; }; websocket.onclose = function() { console.log('websocket close'); }; websocket.onmessage = function(e) { console.log(e.data); document.getElementById('recv').innerHTML = e.data; }; document.getElementById('sendBtn').onclick = function() { var txt = document.getElementById('sendTxt').value; websocket.send(txt); }; nodejs 搭建 WebSocket Server var ws = require('nodejs-websocket'); var PORT = 8001; // Scream server example: \"hi\" -> \"HI!!!\" var server = ws .createServer(function(conn) { console.log('New connection'); conn.on('text', function(str) { console.log('Received ' + str); conn.sendText(str.toUpperCase() + '!!!'); }); conn.on('close', function(code, reason) { console.log('Connection closed'); }); conn.on('error', function(err) { console.log('handle err'); console.log(err); }); }) .listen(PORT); console.log('websocket server listening on port' + PORT); socket.io socket.io 是一个跨浏览器支持 WebSocket 的实时通讯的 JS。 socket.io 的优势： 在发送数据的时候，可以直接发送 JavaScript 对象； 可以方便自定义消息类型。 socket.io实现简易网页聊天室例子： html: 使用socket.io改进聊天室 Chat Room 发送 var socket = io('ws://localhost:6001/'); function showMessage(str, type) { var div = document.createElement('div'); div.innerHTML = str; if (type == 'enter') { div.style.color = 'cornflowerblue'; } else if (type == 'leave') { div.style.color = 'rosybrown'; } document.body.appendChild(div); } document.getElementById('sendBtn').onclick = function() { var txt = document.getElementById('sendTxt').value; if (txt) { socket.emit('message', txt); } }; socket.on('enter', function(data) { showMessage(data, 'enter'); }); socket.on('message', function(data) { showMessage(data, 'message'); }); socket.on('leave', function(data) { showMessage(data, 'leave'); }); Server: var app = require('http').createServer(); var io = require('socket.io')(app); var PORT = 6001; var clientCount = 0; app.listen(PORT); io.on('connection', function(socket) { clientCount++; socket.nickname = 'user' + clientCount; io.emit('enter', socket.nickname + ' come in'); socket.on('message', function(str) { io.emit('message', socket.nickname + ' says:' + str); }); socket.on('disconnect', function() { io.emit('leave', socket.nickname + ' left'); }); }); console.log('websocket server listening on port' + PORT); "},"frontend/typescript/typescript.html":{"url":"frontend/typescript/typescript.html","title":"TypeScript","keywords":"","body":"TypeScript-本地 compiler(ts 转成 js) npm install typescript -g tsc xxx.ts 字符串模板 ` ${表达式} ` 析构表达式 {属性名,属性名}=对象 参数 参数类型 // 参数:后指定类型，类型可以是自定义类型 var name:string = 'kiss'; var a:any ='sss'; var age:number =10; var f:boolean =true; function test(name:string):string{ return 'sdfsdf'; } 默认值 参数:类型=默认值 "},"frontend/react/react.html":{"url":"frontend/react/react.html","title":"React","keywords":"","body":"React React 绑定 this 的三种方式 构造函数内绑定: 在构造函数 constructor 内绑定 this，好处是仅需要绑定一次，避免每次渲染时都要重新绑定，函数在别处复用时也无需再次绑定 import React, {Component} from 'react' class Test extends React.Component { constructor (props) { super(props) this.state = {message: 'Allo!'} this.handleClick = this.handleClick.bind(this) } handleClick (e) { console.log(this.state.message) } render () { return ( Say Hello ) } } 箭头函数: 箭头函数则会捕获其所在上下文的 this 值，作为自己的 this 值，使用箭头函数就不用担心函数内的 this 不是指向组件内部了。 class Test extends React.Component { constructor (props) { super(props) this.state = {message: 'Allo!'} } handleClick (e) { console.log(this.state.message) } render () { return ( { this.handleClick() } }>Say Hello ) } } 这种方式有个小问题，因为箭头函数总是匿名的，如果你打算移除监听事件，可以改用以下方式： class Test extends React.Component { constructor (props) { super(props) this.state = {message: 'Allo!'} } handleClick = (e) => { console.log(this.state.message) } render () { return ( Say Hello ) } } "},"frontend/vue/vue.html":{"url":"frontend/vue/vue.html","title":"Vue","keywords":"","body":"Vue 创建 Vue 实例 把定义的数据与模版结合起来生成要展示的内容，再把这个内容放在挂载点中。vue 只会对它所对应的挂载点内的内容产生作用. 数据定义在data属性里,在方法里访问数据 this.属性名 方法定义在methods属性里。 {{ message }} var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, methods:{ }, watch:{ }, computed:{ } }) {{}} v-text v-html {{}} 显示文本 Message:{{msg}} v-text v-html v-html将文本解析成 html 结构 v-bind 元素节点的属性绑定，简写: imooc imooc v-model 双向数据绑定,表单元素v-model=\"数据的属性名\" v-on 事件绑定，简写@ count: +- v-if 条件表达式 0\">count的值大于0 count的值等于0 count的值小于0 v-show 隐藏 显示 v-for 循环 watch 监听器，Vue 实例的 watch 属性对象， // 监听 watch: { // 监听已有的属性 count: function(newVal, oldVal) { console.log('newVal:' + newVal + ' oldVal:' + oldVal); } } computed 计算属性，Vue 实例的 computed 属性对象 //计算 computed: { // 由已有属性(可以是多个)计算出新的值,已有属性改变后重新计算 hello1: function() { return this.hello.toLocaleUpperCase(); } } 元素节点的样式 style 绑定style,值为样式对象。 style: { color: 'red' } class 绑定class,值可以为数组。条件表达式要写成对象形式，语法:{'className':条件表达式} 0} ]\"> Vue Router 路由管理 Document Hello App! 默认会被渲染成一个 `` 标签 --> Go to Foo Go to Bar // 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter) // 1. 定义 (路由) 组件。 // 可以从其他文件 import 进来 const Foo = { template: 'foo' }; const Bar = { template: 'bar' }; // 2. 定义路由 // 每个路由应该映射一个组件。 其中\"component\" 可以是 // 通过 Vue.extend() 创建的组件构造器， // 或者，只是一个组件配置对象。 // 我们晚点再讨论嵌套路由。 const routes = [ { name: 'foo', path: '/foo', component: Foo }, { name: 'bar', path: '/bar', component: Bar } ]; // 3. 创建 router 实例，然后传 `routes` 配置 // 你还可以传别的配置参数, 不过先这么简单着吧。 const router = new VueRouter({ routes // (缩写) 相当于 routes: routes }); // 4. 创建和挂载根实例。 // 记得要通过 router 配置参数注入路由， // 从而让整个应用都有路由功能 const app = new Vue({ router }).$mount('#app'); // 现在，应用已经启动了！ axios > Document Bitcoin Price Index We're sorry, we're not able to retrieve this information at the moment, please try back later Loading... : new Vue({ el: '#app', data() { return { info: null, loading: true, errored: false }; }, mounted() { axios .get('https://api.coindesk.com/v1/bpi/currentprice.json') .then(response => { this.info = response.data.bpi; }) .catch(error => { console.log(error); this.errored = true; }) .finally(() => (this.loading = false)); } }); Vue-CLI 安装：npm install -g @vue/cli 生成项目：vue create projectName "},"frontend/webpack/webpack.html":{"url":"frontend/webpack/webpack.html","title":"webpack","keywords":"","body":"webpack 安装: npm install webpack --save-dev webpack 4+ 版本: npm install --save-dev webpack-cli webpack配置文件: webpack.config.js是默认的 webpack 配置文件。 webpack命令 可以通过 npm 脚本运行 webpack 命令；并且添加一些参数,比如指定配置文件、查看打包过程。 webpack 基本配置 入口(entry): 入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中. 出口(output): output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： const path = require('path'); const config = { entry: { app: './src/app.js', search: './src/search.js' }, output: { filename: '[name].js', path: path.resolve(__dirname, 'dist') } }; module.exports = config; 生成 html html-webpack-plugin const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装 const webpack = require('webpack'); //访问内置的插件 const path = require('path'); const config = { entry: { app: './src/app.js', search: './src/search.js' }, output: { filename: '[name].js', path: path.resolve(__dirname, 'dist') }, module: { }, plugins: [ new HtmlWebpackPlugin({template: './src/index.html'}) ] }; module.exports = config; 处理资源文件 loader: loader 用于对模块的源代码进行转换。loader 可以使你在 import 或\"加载\"模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS 文件！ ES6转换 babel-loader 处理css|less|sass|stylus 处理模板文件 html-loader 处理图片 file-loader url-loader 数据文件 webpack-dev-server webpack-dev-server 能够用于快速开发应用程序 publicPath: 服务器运行在 http://localhost:8080 并且 output.filename 被设置为 bundle.js。默认 publicPath 是 \"/\"，所以你的包(bundle)可以通过 http://localhost:8080/bundle.js 访问。 可以修改 publicPath，将 bundle 放在一个目录：publicPath: \"/assets/\",你的包现在可以通过 http://localhost:8080/assets/bundle.js 访问。 确保 publicPath 总是以斜杠(/)开头和结尾。 "},"gitproject/":{"url":"gitproject/","title":"Git 项目目录","keywords":"","body":"Git 项目 java base javascript "}}